//! Rich Nickel Package Generation with Enhanced Features
//!
//! Implements Phase 11 of the Amalgam project - creating discoverable,
//! LSP-friendly packages with rich APIs and consistent mod.ncl patterns.

use crate::{Codegen, CodegenError};
use amalgam_core::{
    ir::{Module, TypeDefinition},
    types::Type,
    IR,
};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::Path;

/// Configuration for rich Nickel package generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichPackageConfig {
    /// Package name
    pub name: String,
    /// Package version
    pub version: String,
    /// Package description
    pub description: String,
    /// Whether to generate pattern libraries
    pub generate_patterns: bool,
    /// Whether to include usage examples
    pub include_examples: bool,
    /// Whether to generate LSP hints
    pub lsp_friendly: bool,
    /// Common types to promote to root level
    pub promoted_types: Vec<String>,
    /// API groups to expose
    pub api_groups: Vec<String>,
}

impl Default for RichPackageConfig {
    fn default() -> Self {
        Self {
            name: "generated".to_string(),
            version: "0.1.0".to_string(),
            description: "Generated by Amalgam".to_string(),
            generate_patterns: true,
            include_examples: true,
            lsp_friendly: true,
            promoted_types: vec![
                "Pod".to_string(),
                "Service".to_string(),
                "Deployment".to_string(),
                "ConfigMap".to_string(),
                "Secret".to_string(),
            ],
            api_groups: vec![
                "core".to_string(),
                "apps".to_string(),
                "networking".to_string(),
                "storage".to_string(),
            ],
        }
    }
}

/// Rich Nickel package generator
pub struct RichNickelGenerator {
    config: RichPackageConfig,
    /// Map of version to modules in that version
    version_modules: HashMap<String, Vec<Module>>,
    /// Map of API group to versions
    api_groups: HashMap<String, HashSet<String>>,
    /// Common patterns detected
    patterns: Vec<Pattern>,
}

#[derive(Debug, Clone)]
struct Pattern {
    name: String,
    description: String,
    template: String,
    example: String,
}

impl RichNickelGenerator {
    pub fn new(config: RichPackageConfig) -> Self {
        Self {
            config,
            version_modules: HashMap::new(),
            api_groups: HashMap::new(),
            patterns: Vec::new(),
        }
    }

    /// Analyze IR to build package structure
    pub fn analyze(&mut self, ir: &IR) -> Result<(), CodegenError> {
        for module in &ir.modules {
            // Extract version from module name
            let version = extract_version(&module.name);

            // Group modules by version
            self.version_modules
                .entry(version.clone())
                .or_default()
                .push(module.clone());

            // Extract API group
            if let Some(api_group) = extract_api_group(&module.name) {
                self.api_groups
                    .entry(api_group)
                    .or_default()
                    .insert(version.clone());
            }
        }

        // Detect common patterns
        if self.config.generate_patterns {
            self.patterns = detect_patterns(ir);
        }

        Ok(())
    }

    /// Generate the complete rich package structure
    pub fn generate_package(&self, output_dir: &Path) -> Result<(), CodegenError> {
        // Create package directory structure
        fs::create_dir_all(output_dir)?;

        // Generate root mod.ncl with rich exports
        self.generate_root_module(output_dir)?;

        // Generate Nickel-pkg.ncl with metadata
        self.generate_package_metadata(output_dir)?;

        // Generate version modules
        for (version, modules) in &self.version_modules {
            self.generate_version_module(output_dir, version, modules)?;
        }

        // Generate API group modules
        for (api_group, versions) in &self.api_groups {
            self.generate_api_group_module(output_dir, api_group, versions)?;
        }

        // Generate pattern library
        if self.config.generate_patterns && !self.patterns.is_empty() {
            self.generate_patterns_library(output_dir)?;
        }

        // Generate examples
        if self.config.include_examples {
            self.generate_examples(output_dir)?;
        }

        Ok(())
    }

    /// Generate the root mod.ncl with rich, discoverable API
    fn generate_root_module(&self, output_dir: &Path) -> Result<(), CodegenError> {
        let mut content = String::new();

        // Header
        content.push_str(&format!(
            "# Package: {}\n\
             # Version: {}\n\
             # Description: {}\n\
             # Generated by Amalgam - Rich Nickel Package\n\n",
            self.config.name, self.config.version, self.config.description
        ));

        content.push_str("{\n");

        // Direct version access
        content.push_str("  # Direct version access\n");
        for version in self.version_modules.keys() {
            content.push_str(&format!(
                "  {} = import \"./{}/mod.ncl\",\n",
                version.replace('.', "_"),
                version
            ));
        }
        content.push('\n');

        // API group navigation
        if !self.api_groups.is_empty() {
            content.push_str("  # API group navigation\n");
            for api_group in &self.config.api_groups {
                if self.api_groups.contains_key(api_group) {
                    content.push_str(&format!("  {} = {{\n", api_group));
                    if let Some(versions) = self.api_groups.get(api_group) {
                        for version in versions {
                            content.push_str(&format!(
                                "    {} = import \"./api/{}/{}/mod.ncl\",\n",
                                version.replace('.', "_"),
                                api_group,
                                version
                            ));
                        }
                    }
                    content.push_str("  },\n");
                }
            }
            content.push('\n');
        }

        // Promoted common types for convenience
        if !self.config.promoted_types.is_empty() {
            content.push_str("  # Promoted common types for convenience\n");
            for type_name in &self.config.promoted_types {
                // Try to find the type in v1 first, then other versions
                if let Some(import_path) = self.find_type_import_path(type_name) {
                    content.push_str(&format!(
                        "  {} = (import \"{}\").{},\n",
                        type_name, import_path, type_name
                    ));
                }
            }
            content.push('\n');
        }

        // Usage patterns library
        if self.config.generate_patterns {
            content.push_str("  # Usage patterns library\n");
            content.push_str("  patterns = import \"./patterns/mod.ncl\",\n\n");
        }

        // Package introspection
        content.push_str("  # Package introspection\n");
        content.push_str("  __meta = import \"./Nickel-pkg.ncl\",\n");

        // List all versions
        let versions: Vec<String> = self.version_modules.keys().cloned().collect();
        content.push_str(&format!(
            "  __versions = [{}],\n",
            versions
                .iter()
                .map(|v| format!("\"{}\"", v))
                .collect::<Vec<_>>()
                .join(", ")
        ));

        // List all API groups
        let api_groups: Vec<String> = self.api_groups.keys().cloned().collect();
        content.push_str(&format!(
            "  __api_groups = [{}],\n",
            api_groups
                .iter()
                .map(|g| format!("\"{}\"", g))
                .collect::<Vec<_>>()
                .join(", ")
        ));

        // LSP hints
        if self.config.lsp_friendly {
            content.push_str("\n  # LSP hints for better IDE support\n");
            content.push_str("  __lsp_hints = {\n");
            content.push_str("    type_completions = true,\n");
            content.push_str("    inline_documentation = true,\n");
            content.push_str("    contract_validation = true,\n");
            content.push_str("  },\n");
        }

        content.push_str("}\n");

        fs::write(output_dir.join("mod.ncl"), content)?;
        Ok(())
    }

    /// Generate rich package metadata
    fn generate_package_metadata(&self, output_dir: &Path) -> Result<(), CodegenError> {
        let mut content = String::new();

        content.push_str(&format!(
            "# Nickel Package Metadata\n\
             # Enhanced metadata for {}\n\n",
            self.config.name
        ));

        content.push_str("{\n");
        content.push_str(&format!("  name = \"{}\",\n", self.config.name));
        content.push_str(&format!("  version = \"{}\",\n", self.config.version));
        content.push_str(&format!(
            "  description = \"{}\",\n",
            self.config.description
        ));
        content.push('\n');

        // Version information
        content.push_str("  # Version information\n");
        content.push_str("  versions = {\n");

        // Categorize versions
        let mut stable = Vec::new();
        let mut beta = Vec::new();
        let mut alpha = Vec::new();

        for version in self.version_modules.keys() {
            if version.contains("alpha") {
                alpha.push(version.clone());
            } else if version.contains("beta") {
                beta.push(version.clone());
            } else {
                stable.push(version.clone());
            }
        }

        content.push_str(&format!(
            "    stable = [{}],\n",
            stable
                .iter()
                .map(|v| format!("\"{}\"", v))
                .collect::<Vec<_>>()
                .join(", ")
        ));
        content.push_str(&format!(
            "    beta = [{}],\n",
            beta.iter()
                .map(|v| format!("\"{}\"", v))
                .collect::<Vec<_>>()
                .join(", ")
        ));
        content.push_str(&format!(
            "    alpha = [{}],\n",
            alpha
                .iter()
                .map(|v| format!("\"{}\"", v))
                .collect::<Vec<_>>()
                .join(", ")
        ));
        content.push_str("  },\n\n");

        // API group structure
        content.push_str("  # API group structure\n");
        content.push_str("  api_groups = {\n");
        for (group, versions) in &self.api_groups {
            let type_count = self.count_types_in_group(group);
            content.push_str(&format!(
                "    {} = {{ versions = [{}], types_count = {} }},\n",
                group,
                versions
                    .iter()
                    .map(|v| format!("\"{}\"", v))
                    .collect::<Vec<_>>()
                    .join(", "),
                type_count
            ));
        }
        content.push_str("  },\n\n");

        // Package capabilities
        content.push_str("  # Package capabilities\n");
        content.push_str("  features = {\n");
        content.push_str("    contracts = true,\n");
        content.push_str("    validation = true,\n");
        content.push_str(&format!(
            "    patterns = {},\n",
            self.config.generate_patterns
        ));
        content.push_str(&format!(
            "    examples = {},\n",
            self.config.include_examples
        ));
        content.push_str(&format!(
            "    lsp_friendly = {},\n",
            self.config.lsp_friendly
        ));
        content.push_str("    documentation = true,\n");
        content.push_str("  },\n\n");

        // Integration info
        content.push_str("  # Integration info\n");
        content.push_str("  repository = \"https://github.com/seryl/nickel-pkgs\",\n");
        content.push_str(&format!(
            "  homepage = \"https://nickel-pkgs.dev/{}\",\n",
            self.config.name.replace('_', "-")
        ));
        content.push_str("  license = \"MIT\",\n");
        content.push_str("  authors = [\"amalgam\"],\n");

        // Statistics
        content.push_str("\n  # Package statistics\n");
        content.push_str("  statistics = {\n");
        content.push_str(&format!(
            "    total_types = {},\n",
            self.count_total_types()
        ));
        content.push_str(&format!(
            "    total_modules = {},\n",
            self.version_modules.len()
        ));
        content.push_str(&format!("    pattern_count = {},\n", self.patterns.len()));
        content.push_str("    generation_date = \"2025-09-15\",\n");
        content.push_str("    amalgam_version = \"0.7.0\",\n");
        content.push_str("  },\n");

        content.push_str("}\n");

        fs::write(output_dir.join("Nickel-pkg.ncl"), content)?;
        Ok(())
    }

    /// Generate version module with all types for that version
    fn generate_version_module(
        &self,
        output_dir: &Path,
        version: &str,
        modules: &[Module],
    ) -> Result<(), CodegenError> {
        let version_dir = output_dir.join(version);
        fs::create_dir_all(&version_dir)?;

        let mut content = String::new();
        content.push_str(&format!(
            "# Version: {}\n\
             # Types for {} version\n\n",
            version, version
        ));

        content.push_str("{\n");

        // Export all types from all modules in this version
        for module in modules {
            for type_def in &module.types {
                content.push_str(&format!(
                    "  {} = {},\n",
                    type_def.name,
                    generate_type_definition(type_def)
                ));
            }
        }

        content.push_str("}\n");

        fs::write(version_dir.join("mod.ncl"), content)?;
        Ok(())
    }

    /// Generate API group module
    fn generate_api_group_module(
        &self,
        output_dir: &Path,
        api_group: &str,
        versions: &HashSet<String>,
    ) -> Result<(), CodegenError> {
        let api_dir = output_dir.join("api").join(api_group);

        for version in versions {
            let version_dir = api_dir.join(version);
            fs::create_dir_all(&version_dir)?;

            // Generate mod.ncl for this API group version
            let mut content = String::new();
            content.push_str(&format!(
                "# API Group: {}\n\
                 # Version: {}\n\n",
                api_group, version
            ));

            content.push_str("{\n");

            // Find and export types for this API group and version
            if let Some(modules) = self.version_modules.get(version) {
                for module in modules {
                    if module.name.contains(api_group) {
                        for type_def in &module.types {
                            content.push_str(&format!(
                                "  {} = import \"../../{}/mod.ncl\".{},\n",
                                type_def.name, version, type_def.name
                            ));
                        }
                    }
                }
            }

            content.push_str("}\n");

            fs::write(version_dir.join("mod.ncl"), content)?;
        }

        Ok(())
    }

    /// Generate patterns library
    fn generate_patterns_library(&self, output_dir: &Path) -> Result<(), CodegenError> {
        let patterns_dir = output_dir.join("patterns");
        fs::create_dir_all(&patterns_dir)?;

        // Generate pattern index
        let mut index_content = String::new();
        index_content.push_str("# Pattern Library\n");
        index_content.push_str("# Common usage patterns for this package\n\n");
        index_content.push_str("{\n");

        for pattern in &self.patterns {
            index_content.push_str(&format!(
                "  {} = import \"./{}.ncl\",\n",
                pattern.name.to_lowercase().replace(' ', "_"),
                pattern.name.to_lowercase().replace(' ', "_")
            ));

            // Generate individual pattern file
            self.generate_pattern_file(&patterns_dir, pattern)?;
        }

        index_content.push_str("}\n");

        fs::write(patterns_dir.join("mod.ncl"), index_content)?;
        Ok(())
    }

    /// Generate individual pattern file
    fn generate_pattern_file(
        &self,
        patterns_dir: &Path,
        pattern: &Pattern,
    ) -> Result<(), CodegenError> {
        let mut content = String::new();

        content.push_str(&format!(
            "# Pattern: {}\n\
             # Description: {}\n\n",
            pattern.name, pattern.description
        ));

        content.push_str(&format!("# Template function for {}\n", pattern.name));
        content.push_str(&pattern.template);
        content.push_str("\n\n");

        content.push_str("# Example usage:\n");
        content.push_str(&format!("# {}\n", pattern.example));

        let filename = format!("{}.ncl", pattern.name.to_lowercase().replace(' ', "_"));
        fs::write(patterns_dir.join(filename), content)?;
        Ok(())
    }

    /// Generate usage examples
    fn generate_examples(&self, output_dir: &Path) -> Result<(), CodegenError> {
        let examples_dir = output_dir.join("examples");
        fs::create_dir_all(&examples_dir)?;

        // Generate basic usage example
        let mut content = String::new();
        content.push_str(&format!(
            "# Example: Basic Usage of {}\n\n",
            self.config.name
        ));

        content.push_str("let pkg = import \"../mod.ncl\" in\n");
        content.push_str("{\n");

        // Example with promoted types
        if self.config.promoted_types.contains(&"Pod".to_string()) {
            content.push_str("  # Using promoted Pod type\n");
            content.push_str("  my_pod = pkg.Pod & {\n");
            content.push_str("    metadata.name = \"example-pod\",\n");
            content.push_str("    spec.containers = [{\n");
            content.push_str("      name = \"app\",\n");
            content.push_str("      image = \"nginx:latest\",\n");
            content.push_str("    }],\n");
            content.push_str("  },\n\n");
        }

        // Example with version access
        content.push_str("  # Using specific version\n");
        if let Some(version) = self.version_modules.keys().next() {
            content.push_str(&format!(
                "  versioned_type = pkg.{}.SomeType & {{\n",
                version.replace('.', "_")
            ));
            content.push_str("    # type configuration\n");
            content.push_str("  },\n\n");
        }

        // Example with patterns
        if self.config.generate_patterns && !self.patterns.is_empty() {
            content.push_str("  # Using pattern library\n");
            content.push_str("  from_pattern = pkg.patterns.web_app_template {\n");
            content.push_str("    name = \"my-app\",\n");
            content.push_str("    replicas = 3,\n");
            content.push_str("  },\n");
        }

        content.push_str("}\n");

        fs::write(examples_dir.join("basic_usage.ncl"), content)?;
        Ok(())
    }

    // Helper methods

    fn find_type_import_path(&self, type_name: &str) -> Option<String> {
        // First try v1
        if let Some(modules) = self.version_modules.get("v1") {
            for module in modules {
                if module.types.iter().any(|t| t.name == type_name) {
                    return Some("./v1/mod.ncl".to_string());
                }
            }
        }

        // Try other versions
        for (version, modules) in &self.version_modules {
            if version != "v1" {
                for module in modules {
                    if module.types.iter().any(|t| t.name == type_name) {
                        return Some(format!("./{}/mod.ncl", version));
                    }
                }
            }
        }

        None
    }

    fn count_types_in_group(&self, group: &str) -> usize {
        let mut count = 0;
        for modules in self.version_modules.values() {
            for module in modules {
                if module.name.contains(group) {
                    count += module.types.len();
                }
            }
        }
        count
    }

    fn count_total_types(&self) -> usize {
        self.version_modules
            .values()
            .flat_map(|modules| modules.iter())
            .map(|module| module.types.len())
            .sum()
    }
}

// Helper functions

fn extract_version(module_name: &str) -> String {
    // Extract version from module name (e.g., "k8s.io.v1" -> "v1")
    if let Some(pos) = module_name.rfind('.') {
        let potential_version = &module_name[pos + 1..];
        if potential_version.starts_with('v') {
            return potential_version.to_string();
        }
    }
    "v1".to_string() // Default
}

fn extract_api_group(module_name: &str) -> Option<String> {
    // Extract API group (e.g., "k8s.io.api.core.v1" -> "core")
    let parts: Vec<&str> = module_name.split('.').collect();

    // Look for common API group names
    for part in &parts {
        if matches!(
            *part,
            "core" | "apps" | "networking" | "storage" | "batch" | "policy"
        ) {
            return Some(part.to_string());
        }
    }

    None
}

fn detect_patterns(ir: &IR) -> Vec<Pattern> {
    let mut patterns = Vec::new();

    // Detect common patterns based on type names and structure
    let has_pod = ir
        .modules
        .iter()
        .any(|m| m.types.iter().any(|t| t.name == "Pod"));
    let has_service = ir
        .modules
        .iter()
        .any(|m| m.types.iter().any(|t| t.name == "Service"));
    let has_deployment = ir
        .modules
        .iter()
        .any(|m| m.types.iter().any(|t| t.name == "Deployment"));

    if has_pod && has_service {
        patterns.push(Pattern {
            name: "Web App Template".to_string(),
            description: "Complete web application with Pod and Service".to_string(),
            template: r#"fun { name, image, port ? 80, replicas ? 1 } =>
  {
    pod = Pod & {
      metadata.name = name,
      spec.containers = [{
        name = "app",
        image = image,
        ports = [{ containerPort = port }],
      }],
    },
    service = Service & {
      metadata.name = name ++ "-svc",
      spec = {
        selector.app = name,
        ports = [{ port = port, targetPort = port }],
      },
    },
  }"#
            .to_string(),
            example: r#"web_app_template { name = "nginx", image = "nginx:latest", port = 80 }"#
                .to_string(),
        });
    }

    if has_deployment {
        patterns.push(Pattern {
            name: "Scalable App".to_string(),
            description: "Deployment with configurable replicas".to_string(),
            template: r#"fun { name, image, replicas ? 3, resources ? {} } =>
  Deployment & {
    metadata.name = name,
    spec = {
      replicas = replicas,
      selector.matchLabels.app = name,
      template = {
        metadata.labels.app = name,
        spec.containers = [{
          name = "app",
          image = image,
          resources = resources,
        }],
      },
    },
  }"#
            .to_string(),
            example: r#"scalable_app { name = "api", image = "api:v1", replicas = 5 }"#.to_string(),
        });
    }

    patterns
}

fn generate_type_definition(type_def: &TypeDefinition) -> String {
    // Generate a simple type definition
    // In a real implementation, this would generate full Nickel type with contracts
    let mut content = String::new();

    // Extract fields if this is a Record type
    if let Type::Record { fields, .. } = &type_def.ty {
        content.push_str("{\n");
        for (field_name, field) in fields {
            content.push_str(&format!(
                "    {} | doc \"{}\" | default = {},\n",
                field_name,
                field.description.as_deref().unwrap_or(""),
                generate_default_value(&field.ty)
            ));
        }
        content.push_str("  }");
    } else {
        // For non-record types, generate a simple representation
        content.push_str(&format!("# Type: {}", type_def.name));
    }

    content
}

fn generate_default_value(field_type: &Type) -> String {
    use amalgam_core::types::Type;

    match field_type {
        Type::String => "\"\"".to_string(),
        Type::Integer | Type::Number => "0".to_string(),
        Type::Bool => "false".to_string(),
        Type::Array(_) => "[]".to_string(),
        Type::Record { .. } => "{}".to_string(),
        Type::Optional(_) => "null".to_string(),
        _ => "{}".to_string(),
    }
}

impl Codegen for RichNickelGenerator {
    fn generate(&mut self, ir: &IR) -> Result<String, CodegenError> {
        // Analyze the IR
        self.analyze(ir)?;

        // For string output, generate a summary
        let mut output = String::new();
        output.push_str(&format!("# Rich Nickel Package: {}\n", self.config.name));
        output.push_str(&format!("# Version: {}\n", self.config.version));
        output.push_str(&format!(
            "# Versions: {}\n",
            self.version_modules
                .keys()
                .cloned()
                .collect::<Vec<_>>()
                .join(", ")
        ));
        output.push_str(&format!(
            "# API Groups: {}\n",
            self.api_groups
                .keys()
                .cloned()
                .collect::<Vec<_>>()
                .join(", ")
        ));
        output.push_str(&format!("# Total Types: {}\n", self.count_total_types()));
        output.push_str(&format!("# Patterns: {}\n", self.patterns.len()));

        Ok(output)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use amalgam_core::ir::{Module, TypeDefinition};

    #[test]
    fn test_rich_package_generation() {
        let config = RichPackageConfig::default();
        let mut generator = RichNickelGenerator::new(config);

        // Create test IR
        let mut ir = IR::new();
        let module = Module {
            name: "k8s.io.api.core.v1".to_string(),
            imports: vec![],
            types: vec![TypeDefinition {
                name: "Pod".to_string(),
                ty: Type::Record {
                    fields: Default::default(),
                    open: false,
                },
                documentation: Some("Pod type".to_string()),
                annotations: Default::default(),
            }],
            constants: vec![],
            metadata: Default::default(),
        };
        ir.add_module(module);

        // Analyze
        generator.analyze(&ir).unwrap();

        // Check version extraction
        assert!(generator.version_modules.contains_key("v1"));

        // Check API group extraction
        assert!(generator.api_groups.contains_key("core"));
    }

    #[test]
    fn test_pattern_detection() {
        let mut ir = IR::new();

        // Add Pod and Service types
        let pod_module = Module {
            name: "k8s.io.v1".to_string(),
            imports: vec![],
            types: vec![
                TypeDefinition {
                    name: "Pod".to_string(),
                    ty: Type::Record {
                        fields: Default::default(),
                        open: false,
                    },
                    documentation: None,
                    annotations: Default::default(),
                },
                TypeDefinition {
                    name: "Service".to_string(),
                    ty: Type::Record {
                        fields: Default::default(),
                        open: false,
                    },
                    documentation: None,
                    annotations: Default::default(),
                },
            ],
            constants: vec![],
            metadata: Default::default(),
        };
        ir.add_module(pod_module);

        let patterns = detect_patterns(&ir);
        assert!(!patterns.is_empty());
        assert!(patterns.iter().any(|p| p.name.contains("Web App")));
    }

    #[test]
    fn test_version_categorization() {
        let config = RichPackageConfig::default();
        let mut generator = RichNickelGenerator::new(config);

        // Add various version modules
        generator.version_modules.insert("v1".to_string(), vec![]);
        generator
            .version_modules
            .insert("v1alpha1".to_string(), vec![]);
        generator
            .version_modules
            .insert("v1beta1".to_string(), vec![]);
        generator.version_modules.insert("v2".to_string(), vec![]);

        // Test categorization in metadata generation
        assert_eq!(generator.version_modules.len(), 4);
        assert!(generator.version_modules.contains_key("v1alpha1"));
    }
}
