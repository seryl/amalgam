//! Library interface for amalgam CLI components

pub mod manifest;
pub mod validate;
mod vendor;

use amalgam_parser::k8s_types::K8sTypesFetcher;
use anyhow::Result;
use std::fs;
use std::path::Path;
use tracing::info;

pub async fn handle_k8s_core_import(
    version: &str,
    output_base: &Path,
    _nickel_package: bool, // Legacy parameter - we now always generate manifests
) -> Result<()> {
    info!(
        "Fetching Kubernetes {} core types using unified pipeline...",
        version
    );

    // Automatically create k8s_io subdirectory if the output path doesn't end with it
    // This matches the behavior of package managers like npm, cargo, etc.
    let output_dir = if output_base
        .file_name()
        .map(|name| name.to_string_lossy())
        .map(|name| name == "k8s_io")
        .unwrap_or(false)
    {
        // Output path already ends with k8s_io, use it directly
        output_base.to_path_buf()
    } else {
        // Create k8s_io subdirectory in the specified output directory
        output_base.join("k8s_io")
    };

    info!("Generating k8s types in: {:?}", output_dir);

    // Create fetcher
    let fetcher = K8sTypesFetcher::new();

    // Fetch the OpenAPI schema
    let openapi = fetcher.fetch_k8s_openapi(version).await?;

    // Extract core types
    let types_map = fetcher.extract_core_types(&openapi)?;

    let total_types = types_map.len();
    info!("Extracted {} core types", total_types);

    // Create a NamespacedPackage to use the unified pipeline
    let mut package = amalgam_parser::package::NamespacedPackage::new("k8s.io".to_string());

    // Add all types to the package
    for (type_ref, type_def) in types_map {
        package.add_type(
            "k8s.io".to_string(),
            type_ref.version.clone(),
            type_ref.kind.clone(),
            type_def,
        );
    }

    // Get all versions that have types
    let versions = package.versions("k8s.io");

    info!("Processing {} versions", versions.len());

    // Generate files for each version using the unified pipeline
    for version_name in versions {
        let files = package.generate_version_files("k8s.io", &version_name);

        // Write files to disk
        let version_dir = output_dir.join(&version_name);
        fs::create_dir_all(&version_dir)?;

        for (filename, content) in files {
            let file_path = version_dir.join(&filename);
            fs::write(&file_path, content)?;
            info!("Generated {:?}", file_path);
        }
    }

    // Always generate Nickel package files - they're core to Nickel's package system
    {
        let mut version_imports = Vec::new();
        let versions = package.versions("k8s.io");

        for version in versions {
            version_imports.push(format!("  {} = import \"./{}/mod.ncl\",", version, version));
        }

        let package_content = format!(
            "# Kubernetes Core Types Package\n# Generated with unified IR pipeline\n\n{{\n{}\n}}\n",
            version_imports.join("\n")
        );

        let package_path = output_dir.join("mod.ncl");
        fs::write(&package_path, package_content)?;
        info!("Generated package module {:?}", package_path);

        // Generate Nickel-pkg.ncl manifest using the unified pipeline
        use amalgam_codegen::nickel_manifest::{NickelManifestConfig, NickelManifestGenerator};
        use amalgam_core::IR;

        // Build IR from the package
        let mut ir = IR::new();
        if let Some(k8s_types) = package.types.get("k8s.io") {
            for (version_name, version_types) in k8s_types {
                for type_def in version_types.values() {
                    let module = amalgam_core::ir::Module {
                        name: format!("k8s.io.{}", version_name),
                        imports: Vec::new(),
                        types: vec![type_def.clone()],
                        constants: Vec::new(),
                        metadata: Default::default(),
                    };
                    ir.add_module(module);
                }
            }
        }

        let manifest_config = NickelManifestConfig {
            name: "k8s-io".to_string(),
            version: "0.1.0".to_string(),
            minimal_nickel_version: "1.9.0".to_string(),
            description: format!(
                "Kubernetes {} core type definitions generated by Amalgam for Nickel",
                version
            ),
            authors: vec!["amalgam".to_string()],
            license: "Apache-2.0".to_string(),
            keywords: vec![
                "kubernetes".to_string(),
                "k8s".to_string(),
                "types".to_string(),
            ],
            base_package_id: None,
            local_dev_mode: false,
            local_package_prefix: None,
        };

        let generator = NickelManifestGenerator::new(manifest_config);
        let manifest_content = generator
            .generate_manifest(&ir, None)
            .expect("Failed to generate Nickel manifest");

        let manifest_path = output_dir.join("Nickel-pkg.ncl");
        fs::write(&manifest_path, manifest_content)?;
        info!("Generated Nickel manifest {:?}", manifest_path);
    }

    info!(
        "âœ… Successfully generated {} Kubernetes {} types with proper cross-version imports",
        total_types, version
    );

    Ok(())
}
