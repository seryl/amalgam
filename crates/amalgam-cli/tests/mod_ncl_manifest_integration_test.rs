//! Integration tests for mod.ncl generation via manifest.rs
//!
//! These tests verify the full pipeline from directory structure to mod.ncl generation

use amalgam_cli::manifest::Manifest;
use std::collections::BTreeMap;
use std::fs;
use std::path::PathBuf;
use tempfile::TempDir;

#[test]
fn test_generate_rich_mod_ncl_root_level() {
    let temp = TempDir::new().unwrap();
    let base = temp.path();

    // Create package structure
    let pkg_dir = base.join("test_package");
    fs::create_dir_all(&pkg_dir).unwrap();

    // Create some .ncl files
    fs::write(pkg_dir.join("Type1.ncl"), "{}").unwrap();
    fs::write(pkg_dir.join("Type2.ncl"), "{}").unwrap();

    // Create manifest to test with
    let manifest_content = format!(
        r#"
[config]
output_base = "{}"
package_mode = true
base_package_id = "test"
"#,
        base.display()
    );

    let manifest_path = temp.path().join(".amalgam-manifest.toml");
    fs::write(&manifest_path, manifest_content).unwrap();

    let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

    // Create test data
    let mut subdirs = BTreeMap::new();
    let mut files = BTreeMap::new();
    files.insert("Type1".to_string(), "Type1.ncl".to_string());
    files.insert("Type2".to_string(), "Type2.ncl".to_string());

    let output = manifest.generate_rich_mod_ncl(&pkg_dir, &subdirs, &files).unwrap();

    // Verify format
    assert!(output.contains("# Package Root"), "Should have root header");
    assert!(output.contains("# Auto-generated by Amalgam"), "Should have generator line");
    assert!(output.contains("# Generator: amalgam v"), "Should have version");
    assert!(!output.contains("Generated:") || !output.contains("UTC"), "Should not have timestamp");

    // Verify exports
    assert!(output.contains("# Exports:"), "Should list exports");
    assert!(output.contains("#   Type1"), "Should list Type1");
    assert!(output.contains("#   Type2"), "Should list Type2");

    // Verify imports
    assert!(output.contains("Type1 = import \"./Type1.ncl\""), "Should import Type1");
    assert!(output.contains("Type2 = import \"./Type2.ncl\""), "Should import Type2");
}

#[test]
fn test_generate_rich_mod_ncl_group_level() {
    let temp = TempDir::new().unwrap();
    let base = temp.path();

    // Create group structure
    let group_dir = base.join("apiextensions.crossplane.io");
    let v1_dir = group_dir.join("v1");
    let v1beta1_dir = group_dir.join("v1beta1");

    fs::create_dir_all(&v1_dir).unwrap();
    fs::create_dir_all(&v1beta1_dir).unwrap();

    let manifest_content = format!(
        r#"
[config]
output_base = "{}"
package_mode = true
base_package_id = "test"
"#,
        base.display()
    );

    let manifest_path = temp.path().join(".amalgam-manifest.toml");
    fs::write(&manifest_path, manifest_content).unwrap();

    let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

    let mut subdirs = BTreeMap::new();
    subdirs.insert("v1".to_string(), "v1".to_string());
    subdirs.insert("v1beta1".to_string(), "v1beta1".to_string());
    let files = BTreeMap::new();

    let output = manifest.generate_rich_mod_ncl(&group_dir, &subdirs, &files).unwrap();

    // Verify path context
    assert!(output.contains("# Module: apiextensions.crossplane.io"), "Should show module path");

    // Verify submodules listed
    assert!(output.contains("# Submodules:"), "Should list submodules");
    assert!(output.contains("#   - v1/"), "Should list v1");
    assert!(output.contains("#   - v1beta1/"), "Should list v1beta1");

    // Verify imports
    assert!(output.contains("v1 = import \"./v1/mod.ncl\""), "Should import v1");
    assert!(output.contains("v1beta1 = import \"./v1beta1/mod.ncl\""), "Should import v1beta1");
}

#[test]
fn test_hermetic_mod_ncl_generation_via_manifest() {
    let temp1 = TempDir::new().unwrap();
    let temp2 = TempDir::new().unwrap();

    // Create identical structures
    for temp in &[&temp1, &temp2] {
        let base = temp.path();
        let pkg_dir = base.join("test");
        fs::create_dir_all(&pkg_dir).unwrap();
        fs::write(pkg_dir.join("Type.ncl"), "{}").unwrap();

        let manifest_content = format!(
            r#"
[config]
output_base = "{}"
package_mode = true
base_package_id = "test"
"#,
            base.display()
        );
        let manifest_path = temp.path().join(".amalgam-manifest.toml");
        fs::write(&manifest_path, manifest_content).unwrap();
    }

    // Generate from both
    let output1 = {
        let manifest_path = temp1.path().join(".amalgam-manifest.toml");
        let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

        let pkg_dir = temp1.path().join("test");
        let mut subdirs = BTreeMap::new();
        let mut files = BTreeMap::new();
        files.insert("Type".to_string(), "Type.ncl".to_string());

        manifest.generate_rich_mod_ncl(&pkg_dir, &subdirs, &files).unwrap()
    };

    let output2 = {
        let manifest_path = temp2.path().join(".amalgam-manifest.toml");
        let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

        let pkg_dir = temp2.path().join("test");
        let mut subdirs = BTreeMap::new();
        let mut files = BTreeMap::new();
        files.insert("Type".to_string(), "Type.ncl".to_string());

        manifest.generate_rich_mod_ncl(&pkg_dir, &subdirs, &files).unwrap()
    };

    assert_eq!(output1, output2, "Hermetic: same inputs should produce same outputs");
}

#[test]
fn test_mod_ncl_with_crossplane_shows_k8s_reference() {
    let temp = TempDir::new().unwrap();
    let base = temp.path();

    let crossplane_dir = base.join("apiextensions_crossplane_io");
    fs::create_dir_all(&crossplane_dir).unwrap();

    let manifest_content = format!(
        r#"
[config]
output_base = "{}"
package_mode = true
base_package_id = "test"
"#,
        base.display()
    );

    let manifest_path = temp.path().join(".amalgam-manifest.toml");
    fs::write(&manifest_path, manifest_content).unwrap();

    let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

    let subdirs = BTreeMap::new();
    let files = BTreeMap::new();

    let output = manifest.generate_rich_mod_ncl(&crossplane_dir, &subdirs, &files).unwrap();

    // Should mention k8s_io as related
    assert!(output.contains("# Related packages:"), "Should have related packages section");
    assert!(output.contains("k8s_io"), "Should reference k8s_io");
}

#[test]
fn test_mod_ncl_nickel_syntax_validity() {
    let temp = TempDir::new().unwrap();
    let base = temp.path();

    let pkg_dir = base.join("test");
    fs::create_dir_all(&pkg_dir).unwrap();
    fs::write(pkg_dir.join("Type.ncl"), "{}").unwrap();

    let manifest_content = format!(
        r#"
[config]
output_base = "{}"
package_mode = true
base_package_id = "test"
"#,
        base.display()
    );

    let manifest_path = temp.path().join(".amalgam-manifest.toml");
    fs::write(&manifest_path, manifest_content).unwrap();

    let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

    let mut subdirs = BTreeMap::new();
    let mut files = BTreeMap::new();
    files.insert("Type".to_string(), "Type.ncl".to_string());

    let output = manifest.generate_rich_mod_ncl(&pkg_dir, &subdirs, &files).unwrap();

    // Basic Nickel syntax checks
    assert!(output.contains("{\n"), "Should have opening brace");
    assert!(output.ends_with("}\n"), "Should have closing brace");

    let open = output.matches('{').count();
    let close = output.matches('}').count();
    assert_eq!(open, close, "Braces should be balanced");

    // All imports should have proper syntax
    for line in output.lines() {
        if line.contains(" = import ") {
            assert!(line.contains('"'), "Import should have quotes: {}", line);
            assert!(line.trim().ends_with(','), "Import should end with comma: {}", line);
        }
    }
}

#[test]
fn test_mod_ncl_empty_directory_handling() {
    let temp = TempDir::new().unwrap();
    let base = temp.path();

    let empty_dir = base.join("empty");
    fs::create_dir_all(&empty_dir).unwrap();

    let manifest_content = format!(
        r#"
[config]
output_base = "{}"
package_mode = true
base_package_id = "test"
"#,
        base.display()
    );

    let manifest_path = temp.path().join(".amalgam-manifest.toml");
    fs::write(&manifest_path, manifest_content).unwrap();

    let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

    let subdirs = BTreeMap::new();
    let files = BTreeMap::new();

    let output = manifest.generate_rich_mod_ncl(&empty_dir, &subdirs, &files).unwrap();

    // Should still generate valid output even if empty
    assert!(output.contains("# Auto-generated by Amalgam"));
    assert!(output.contains("{\n"));
    assert!(output.ends_with("}\n"));
}

#[test]
fn test_mod_ncl_file_and_subdir_mix() {
    let temp = TempDir::new().unwrap();
    let base = temp.path();

    let pkg_dir = base.join("test");
    let subdir = pkg_dir.join("v1");
    fs::create_dir_all(&subdir).unwrap();
    fs::write(pkg_dir.join("Common.ncl"), "{}").unwrap();

    let manifest_content = format!(
        r#"
[config]
output_base = "{}"
package_mode = true
base_package_id = "test"
"#,
        base.display()
    );

    let manifest_path = temp.path().join(".amalgam-manifest.toml");
    fs::write(&manifest_path, manifest_content).unwrap();

    let manifest: Manifest = toml::from_str(&fs::read_to_string(&manifest_path).unwrap()).unwrap();

    let mut subdirs = BTreeMap::new();
    subdirs.insert("v1".to_string(), "v1".to_string());

    let mut files = BTreeMap::new();
    files.insert("Common".to_string(), "Common.ncl".to_string());

    let output = manifest.generate_rich_mod_ncl(&pkg_dir, &subdirs, &files).unwrap();

    // Should list both
    assert!(output.contains("# Exports:"), "Should list files");
    assert!(output.contains("#   Common"), "Should list Common");
    assert!(output.contains("# Submodules:"), "Should list subdirs");
    assert!(output.contains("#   - v1/"), "Should list v1");

    // Should import both
    assert!(output.contains("v1 = import \"./v1/mod.ncl\""));
    assert!(output.contains("Common = import \"./Common.ncl\""));
}
