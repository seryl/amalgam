//! Package-based CRD importing (similar to CUE's approach)

use crate::{
    crd::{CRDParser, CRD},
    parsing_trace::ParsingTrace,
    ParserError,
};
use amalgam_codegen::nickel_package::{NickelPackageConfig, NickelPackageGenerator, PackageDependency};
use amalgam_core::{
    ir::{Module, TypeDefinition, IR},
    types::Type,
};
use std::collections::{BTreeMap, HashMap};
use std::path::PathBuf;

mod import_extraction_debug;
use import_extraction_debug::{ExtractionAttempt, ImportExtractionDebug};

pub struct PackageGenerator {
    crds: Vec<CRD>,
    package_name: String,
    _base_path: PathBuf,
}

impl PackageGenerator {
    pub fn new(package_name: String, base_path: PathBuf) -> Self {
        Self {
            crds: Vec::new(),
            package_name,
            _base_path: base_path,
        }
    }

    pub fn add_crd(&mut self, crd: CRD) {
        self.crds.push(crd);
    }

    pub fn add_crds(&mut self, crds: Vec<CRD>) {
        self.crds.extend(crds);
    }

    /// Generate a package structure similar to CUE's approach
    /// Creates a directory structure like:
    /// ```text
    /// package_name/
    ///   â”œâ”€â”€ mod.ncl                                    # Main module
    ///   â”œâ”€â”€ apiextensions.crossplane.io/
    ///   â”‚   â”œâ”€â”€ mod.ncl                               # Group module
    ///   â”‚   â”œâ”€â”€ v1/
    ///   â”‚   â”‚   â”œâ”€â”€ mod.ncl                           # Version module
    ///   â”‚   â”‚   â”œâ”€â”€ composition.ncl                   # Type definition
    ///   â”‚   â”‚   â””â”€â”€ compositeresourcedefinition.ncl
    ///   â”‚   â””â”€â”€ v1beta1/
    ///   â”‚       â””â”€â”€ ...
    ///   â””â”€â”€ pkg.crossplane.io/
    ///       â””â”€â”€ ...
    /// ```
    pub fn generate_package(&self) -> Result<NamespacedPackage, ParserError> {
        let mut package = NamespacedPackage::new(self.package_name.clone());

        // Group CRDs by group, version, and kind
        for crd in &self.crds {
            let group = &crd.spec.group;
            let kind_lowercase = crd.spec.names.kind.to_lowercase();
            let _kind_original = crd.spec.names.kind.clone();

            for version in &crd.spec.versions {
                if !version.served {
                    continue; // Skip non-served versions
                }

                // Parse the CRD for this specific version
                let parser = CRDParser::new();
                let ir = parser.parse_version(crd, &version.name)?;

                // Extract the type definition for this version
                if let Some(module) = ir.modules.first() {
                    for type_def in &module.types {
                        // Store by group/version/kind structure with lowercase key
                        // but preserve original casing in the type definition
                        package.add_type(
                            group.clone(),
                            version.name.clone(),
                            kind_lowercase.clone(),
                            type_def.clone(),
                        );
                    }
                }
            }
        }

        Ok(package)
    }
}

/// Represents a package organized by group/version/kind
pub struct NamespacedPackage {
    pub name: String,
    /// group -> version -> kind -> TypeDefinition
    pub types: HashMap<String, HashMap<String, HashMap<String, TypeDefinition>>>,
}

impl NamespacedPackage {
    pub fn new(name: String) -> Self {
        Self {
            name,
            types: HashMap::new(),
        }
    }

    pub fn add_type(
        &mut self,
        group: String,
        version: String,
        kind: String,
        type_def: TypeDefinition,
    ) {
        self.types
            .entry(group)
            .or_default()
            .entry(version)
            .or_default()
            .insert(kind, type_def);
    }

    /// Generate the main module file
    pub fn generate_main_module(&self) -> String {
        let mut content = String::new();
        content.push_str(&format!("# {} - Kubernetes CRD types\n", self.name));
        content.push_str("# Auto-generated by amalgam\n");
        content.push_str("# Structure: group/version/kind\n\n");
        content.push_str("{\n");

        // Sort groups for consistent output
        let mut groups: Vec<_> = self.types.keys().collect();
        groups.sort();

        for group in groups {
            let safe_group = group.replace(['.', '-'], "_");
            content.push_str(&format!(
                "  {} = import \"./{}/mod.ncl\",\n",
                safe_group, group
            ));
        }

        content.push_str("}\n");
        content
    }

    /// Generate a group-level module file
    pub fn generate_group_module(&self, group: &str) -> Option<String> {
        self.types.get(group).map(|versions| {
            let mut content = String::new();
            content.push_str(&format!("# {} group\n", group));
            content.push_str("# Auto-generated by amalgam\n\n");
            content.push_str("{\n");

            // Sort versions for consistent output
            let mut version_list: Vec<_> = versions.keys().collect();
            version_list.sort();

            for version in version_list {
                content.push_str(&format!(
                    "  {} = import \"./{}/mod.ncl\",\n",
                    version, version
                ));
            }

            content.push_str("}\n");
            content
        })
    }

    /// Generate a version-level module file for a group
    pub fn generate_version_module(&self, group: &str, version: &str) -> Option<String> {
        self.types.get(group).and_then(|versions| {
            versions.get(version).map(|kinds| {
                let mut content = String::new();
                content.push_str(&format!("# {}/{} types\n", group, version));
                content.push_str("# Auto-generated by amalgam\n\n");
                content.push_str("{\n");

                // Sort kinds for consistent output
                let mut kind_list: Vec<_> = kinds.keys().collect();
                kind_list.sort();

                for kind in kind_list {
                    // Use the actual type name from the TypeDefinition
                    let type_name = if let Some(type_def) = kinds.get(kind) {
                        type_def.name.clone()
                    } else {
                        capitalize_first(kind)
                    };
                    // Single-type modules now export the type directly (not wrapped in record)
                    // So we can import them directly without extraction
                    // Use original case for the filename
                    content.push_str(&format!(
                        "  {} = import \"./{}.ncl\",\n",
                        type_name,
                        type_name  // Use the type_name which has the correct case
                    ));
                }

                content.push_str("}\n");
                content
            })
        })
    }

    /// Generate all files for a version using unified IR pipeline with walkers
    #[tracing::instrument(skip(self), fields(group = %group, version = %version))]
    pub fn generate_version_files(&self, group: &str, version: &str) -> BTreeMap<String, String> {
        tracing::debug!("generate_version_files called for {}/{}", group, version);
        let mut files = BTreeMap::new();
        let mut trace = ParsingTrace::new();
        let mut import_debug = ImportExtractionDebug::new();

        // Get types for this version
        let types = match self.types.get(group).and_then(|v| v.get(version)) {
            Some(types) => types,
            None => return files,
        };

        // Step 1: Build type registry using the walker adapter
        let registry = match crate::package_walker::PackageWalkerAdapter::build_registry(
            types, group, version,
        ) {
            Ok(reg) => reg,
            Err(e) => {
                tracing::error!("Failed to build type registry: {}", e);
                return files;
            }
        };

        // Step 2: Build dependency graph
        let deps = crate::package_walker::PackageWalkerAdapter::build_dependencies(&registry);

        // Step 3: Generate complete IR with imports
        let ir = match crate::package_walker::PackageWalkerAdapter::generate_ir(
            registry, deps, group, version,
        ) {
            Ok(ir) => ir,
            Err(e) => {
                tracing::error!("Failed to generate IR: {}", e);
                return files;
            }
        };

        // Step 4: Generate files from IR using codegen with complete symbol table
        // The key insight: pass the complete IR so NickelCodegen can build a full symbol table
        let mut codegen = amalgam_codegen::nickel::NickelCodegen::from_ir(&ir);

        tracing::debug!(
            "Generating Nickel files from IR with {} modules using unified pipeline",
            ir.modules.len()
        );

        // Use iterative generation to handle dependency chains
        // Keep generating until no new imports are needed (convergence)
        let mut iteration = 1;
        let max_iterations = 10; // Prevent infinite loops
        
        let (all_generated, type_import_map) = loop {
            tracing::debug!("Import generation iteration {}", iteration);
            
            let (generated, import_map) = codegen
                .generate_with_import_tracking(&ir)
                .unwrap_or_else(|e| {
                    tracing::error!("Code generation failed: {}", e);
                    (
                        format!("# Error generating types: {}\n", e),
                        amalgam_codegen::nickel::TypeImportMap::new(),
                    )
                });

            // Check if this iteration generated new imports
            let import_count = import_map.total_import_count();
            tracing::debug!("Iteration {} generated {} total imports", iteration, import_count);

            // If we've reached max iterations or no new imports, break
            if iteration >= max_iterations {
                tracing::warn!("Reached maximum iterations ({}), breaking", max_iterations);
                break (generated, import_map);
            }
            
            // Continue iterations to handle dependency chains
            iteration += 1;
        };

        // Capture codegen imports for debugging
        for module in &ir.modules {
            for type_def in &module.types {
                let imports = type_import_map.get_imports_for(&type_def.name);
                import_debug.record_codegen_imports(&type_def.name, imports);
            }
        }
        import_debug.record_module_content(&all_generated);

        // Record input characteristics in trace
        trace.record_input(&all_generated, &ir);

        // Parse the module-marked output from NickelCodegen
        // The codegen outputs: # Module: <module_name>\n{\n  TypeDef1 = ...,\n  TypeDef2 = ...,\n}\n

        // Split by module markers
        let module_sections: Vec<&str> = all_generated.split("# Module: ").collect();

        // Debug: log how many modules we found
        if version == "v1" {
            tracing::debug!(
                "Found {} module sections in generated output for v1",
                module_sections.len() - 1
            );
        }

        for (section_idx, section) in module_sections.iter().skip(1).enumerate() {
            // Skip empty first split
            let lines: Vec<&str> = section.lines().collect();
            if lines.is_empty() {
                continue;
            }

            // First line is module name
            let module_name = lines[0].trim();

            // Debug first few module names for v1
            if version == "v1" && section_idx < 3 {
                tracing::debug!(
                    "Module {}: name='{}', has {} lines",
                    section_idx,
                    module_name,
                    lines.len()
                );
            }

            // Rest is the module content
            let module_content = lines[1..].join("\n");

            // Find the module in our IR to get type information
            let module = ir.modules.iter().find(|m| m.name == module_name);

            // Record module parsing step
            trace.record_module_parse(
                section_idx,
                section,
                Some(module_name.to_string()),
                module.is_some(),
                &module_content,
            );

            if let Some(module) = module {
                // Extract each type definition from the module content
                for type_def in &module.types {
                    // Keep the original case for the filename
                    let file_name = format!("{}.ncl", type_def.name);
                    

                    // For single-type modules, export just the type
                    // For multi-type modules, we need to extract the specific type
                    // Get imports for this type from the map
                    let _type_imports = type_import_map.get_imports_for(&type_def.name);

                    let (content, strategy, success, error) = if module.types.len() == 1 {
                        eprintln!("ðŸ›¤ï¸ PATH: Using single-type extraction for '{}'", type_def.name);
                        // Single type - the module content IS the type (after stripping module wrapper)
                        let content = extract_single_type_from_module(
                            &module_content,
                            &type_def.name,
                            Some(&type_import_map),
                            Some(&mut import_debug),
                        );
                        let success = !content.is_empty();
                        (content, "single-type-extraction", success, None)
                    } else {
                        eprintln!("ðŸ›¤ï¸ PATH: Using multi-type extraction for '{}' (module has {} types)", type_def.name, module.types.len());
                        // Multiple types - extract this specific type from the module
                        let content = extract_type_from_module(
                            &module_content,
                            &type_def.name,
                            Some(&type_import_map),
                            Some(&mut import_debug),
                        );
                        let success = !content.is_empty();
                        (content, "multi-type-extraction", success, None)
                    };

                    // Record extraction attempt
                    trace.record_type_extraction(
                        &module.name,
                        &type_def.name,
                        strategy,
                        success,
                        Some(&content),
                        error,
                        &file_name,
                    );

                    if success {
                        // Debug: Log what we're about to write
                        let has_imports = content.lines().any(|l| l.trim().starts_with("let ") && l.contains("import"));
                        tracing::info!(
                            "Writing file {} - has_imports: {}, content_len: {}, first_100_chars: {:?}",
                            file_name,
                            has_imports,
                            content.len(),
                            &content.chars().take(100).collect::<String>()
                        );
                        import_debug.record_final_file(&file_name, &content);
                        files.insert(file_name, content);
                    }
                }
            } else {
                trace.record_type_extraction(
                    module_name,
                    "<unknown>",
                    "module-not-found",
                    false,
                    None,
                    Some(format!("Module {} not found in IR", module_name)),
                    "<unknown>.ncl",
                );
            }
        }

        // Record the result before checking for fallback
        trace.record_result(&files, false);

        // Fallback: if parsing failed, use the module-by-module approach but with complete IR context
        if files.is_empty() {
            eprintln!("ðŸš¨ FALLBACK: Using fallback generation for group '{}' version '{}'", group, version);
            let mut fallback_files = vec![];
            trace.record_fallback(
                "No files extracted from concatenated output",
                "module-by-module generation",
                vec![],
            );

            for module in &ir.modules {
                // Use the actual type name from type definitions, not the module name
                // This ensures we match the TypeImportMap keys correctly
                let type_name = if let Some(type_def) = module.types.first() {
                    &type_def.name
                } else {
                    // Fallback to module name if no types
                    module.name.rsplit('.').next().unwrap_or(&module.name)
                };

                // Create single-module IR but codegen has already built symbol table
                let mut single_ir = IR::new();
                single_ir.add_module(module.clone());

                // Create new codegen instance for each module  
                // IMPORTANT: Use original codegen with complete import context, not a new one
                let (generated_module, _) = codegen
                    .generate_with_import_tracking(&single_ir)
                    .unwrap_or_else(|e| {
                        (
                            format!("# Error generating type: {}\n", e),
                            amalgam_codegen::nickel::TypeImportMap::new(),
                        )
                    });
                
                // Extract the type content and apply imports from the full TypeImportMap
                let generated = extract_single_type_from_module(
                    &generated_module,
                    type_name,
                    Some(&type_import_map),
                    None,
                );

                let file_name = format!("{}.ncl", type_name);
                files.insert(file_name.clone(), generated);
                fallback_files.push(file_name);
            }

            // Update fallback record with generated files
            if let Some(fallback) = trace.fallbacks.last_mut() {
                fallback.files_generated = fallback_files;
            }
        }

        // Generate mod.ncl for this version
        if let Some(mod_content) = self.generate_version_module(group, version) {
            files.insert("mod.ncl".to_string(), mod_content);
        }

        // Export trace for analysis if we're in debug mode or had issues
        if files.is_empty() || trace.result.used_fallback {
            // Update final result if we used fallback
            if trace.result.used_fallback {
                trace.record_result(&files, true);
            }

            tracing::debug!("Parsing trace:\n{}", trace.summary());
            if tracing::enabled!(tracing::Level::DEBUG) {
                tracing::trace!("Full parsing trace JSON:\n{}", trace.to_json());
            }
        }

        // Check if we have import issues and output debug info
        let summary = import_debug.summary();
        // Always output for v1 to debug
        if version == "v1"
            || summary.contains("lost their imports")
            || tracing::enabled!(tracing::Level::DEBUG)
        {
            tracing::debug!(
                "Import extraction debug for {}/{}:\n{}",
                group,
                version,
                summary
            );
            if version == "v1" {
                // Output first few extraction attempts for v1
                for (i, attempt) in import_debug.extraction_attempts.iter().take(5).enumerate() {
                    tracing::trace!(
                        "Extraction attempt {} for {}: imports_from_map={:?}, final_imports={:?}",
                        i,
                        attempt.type_name,
                        attempt.imports_from_map,
                        attempt.final_imports_used
                    );
                }

                // Check specific types that should have imports
                let lifecycle_imports = import_debug.codegen_imports.get("Lifecycle");
                tracing::trace!("Codegen imports for Lifecycle: {:?}", lifecycle_imports);

                let deleteoptions_imports = import_debug.codegen_imports.get("DeleteOptions");
                tracing::trace!(
                    "Codegen imports for DeleteOptions: {:?}",
                    deleteoptions_imports
                );

                // Output pipeline debug summary
                tracing::debug!(
                    "Pipeline Debug Summary:\n{}",
                    codegen.pipeline_debug.summary_string()
                );

                // Check the first few modules in the IR
                for (i, module) in ir.modules.iter().take(5).enumerate() {
                    let type_names: Vec<String> =
                        module.types.iter().map(|t| t.name.clone()).collect();
                    tracing::trace!(
                        "IR Module {}: name='{}', types={:?}",
                        i,
                        module.name,
                        type_names
                    );
                }

                // Get detailed report for specific types
                tracing::trace!(
                    "Lifecycle Report:\n{}",
                    codegen.pipeline_debug.type_report("Lifecycle")
                );
                tracing::trace!(
                    "DeleteOptions Report:\n{}",
                    codegen.pipeline_debug.type_report("DeleteOptions")
                );
            }
        }

        files
    }

    /// Get all groups in the package
    pub fn groups(&self) -> Vec<String> {
        let mut groups: Vec<_> = self.types.keys().cloned().collect();
        groups.sort();
        groups
    }

    /// Get all versions for a group
    pub fn versions(&self, group: &str) -> Vec<String> {
        self.types
            .get(group)
            .map(|versions| {
                let mut version_list: Vec<_> = versions.keys().cloned().collect();
                version_list.sort();
                version_list
            })
            .unwrap_or_default()
    }

    /// Get all kinds for a group/version
    pub fn kinds(&self, group: &str, version: &str) -> Vec<String> {
        self.types
            .get(group)
            .and_then(|versions| {
                versions.get(version).map(|kinds| {
                    let mut kind_list: Vec<_> = kinds.keys().cloned().collect();
                    kind_list.sort();
                    kind_list
                })
            })
            .unwrap_or_default()
    }

    /// Generate a Nickel package manifest (Nickel-pkg.ncl)
    pub fn generate_nickel_manifest(&self, config: Option<NickelPackageConfig>) -> String {
        let config = config.unwrap_or_else(|| NickelPackageConfig {
            name: self.name.clone(),
            description: format!("Generated type definitions for {}", self.name),
            version: "0.1.0".to_string(),
            minimal_nickel_version: "1.9.0".to_string(),
            authors: vec!["amalgam".to_string()],
            license: "Apache-2.0".to_string(),
            keywords: {
                let mut keywords = vec!["kubernetes".to_string(), "types".to_string()];
                // Add groups as keywords
                for group in self.groups() {
                    keywords.push(group.replace('.', "-"));
                }
                keywords
            },
        });

        let generator = NickelPackageGenerator::new(config);

        // Detect if we need k8s.io as a dependency
        let mut dependencies = HashMap::new();
        if self.has_k8s_references() {
            // Add k8s.io as a path dependency (assuming it's in a sibling directory)
            dependencies.insert(
                "k8s_io".to_string(),
                PackageDependency::Path(PathBuf::from("../k8s_io")),
            );
        }

        // Convert our types to modules for the generator
        let modules: Vec<Module> = self
            .groups()
            .into_iter()
            .flat_map(|group| {
                self.versions(&group)
                    .into_iter()
                    .map(move |version| Module {
                        name: format!("{}.{}", group, version),
                        imports: Vec::new(),
                        types: Vec::new(),
                        constants: Vec::new(),
                        metadata: Default::default(),
                    })
            })
            .collect();

        generator
            .generate_manifest(&modules, dependencies)
            .unwrap_or_else(|e| format!("# Error generating manifest: {}\n", e))
    }

    /// Check if any types reference k8s.io types
    fn has_k8s_references(&self) -> bool {
        for versions in self.types.values() {
            for kinds in versions.values() {
                for type_def in kinds.values() {
                    if needs_k8s_imports(&type_def.ty) {
                        return true;
                    }
                }
            }
        }
        false
    }
}

/// Extract a single type definition from a module that contains only one type
fn extract_single_type_from_module(
    module_content: &str,
    type_name: &str,
    type_import_map: Option<&amalgam_codegen::nickel::TypeImportMap>,
    debug: Option<&mut ImportExtractionDebug>,
) -> String {
    eprintln!("ðŸ”§ EXTRACTION: Processing type '{}' in extract_single_type_from_module", type_name);
    
    // Module content can look like:
    // let SomeType_type = import "./sometype.ncl" in   <- imports (optional)
    // {
    //   TypeName = { ... },
    // }
    // We want to extract the imports AND the type definition

    let lines: Vec<&str> = module_content.lines().collect();
    let mut result = Vec::new();
    let mut imports = Vec::new();

    let mut imports_from_map = Vec::new();
    let mut imports_from_content = Vec::new();

    // First, extract any existing imports from the module content
    // Use a HashSet to deduplicate imports that appear multiple times
    let mut existing_imports = std::collections::HashSet::new();
    for line in &lines {
        // Collect import statements (they start with "let" and contain "import")
        if line.trim().starts_with("let ") && line.contains("import") && line.contains(" in") {
            let import_line = line.trim().to_string();
            // Only add if we haven't seen this exact import before
            if existing_imports.insert(import_line.clone()) {
                imports.push(import_line.clone());
                imports_from_content.push(import_line);
                tracing::trace!("Found existing import in content: '{}'", line.trim());
            } else {
                tracing::trace!("Skipping duplicate import: '{}'", line.trim());
            }
        }
    }

    // Always check TypeImportMap and add any imports that aren't already present
    // This ensures all necessary imports are included
    if let Some(import_map) = type_import_map {
        let map_imports = import_map.get_imports_for(type_name);
        eprintln!("ðŸ“¥ EXTRACTION: TypeImportMap check for '{}': found {} imports", type_name, map_imports.len());
        if !map_imports.is_empty() {
            eprintln!("ðŸ“‹ EXTRACTION: Import map contains for type '{}': {:?}", type_name, map_imports);
            for import_stmt in &map_imports {
                // Only add if not already present (avoid duplicates)
                if !existing_imports.contains(import_stmt) {
                    imports.push(import_stmt.clone());
                    imports_from_map.push(import_stmt.clone());
                    tracing::info!("Adding import from map: '{}'", import_stmt);
                } else {
                    tracing::info!("Import already exists, skipping: '{}'", import_stmt);
                }
            }
        }
    } else {
        tracing::warn!("No TypeImportMap provided for type '{}'", type_name);
    }

    // With single-type-per-module format, the entire module content (after imports) is the type definition
    let mut found_type_content = false;
    for line in lines {
        // Skip import lines we've already processed
        if line.trim().starts_with("let ") && line.contains("import") && line.contains(" in") {
            continue;
        }

        // Skip empty lines and comments after imports
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("#") {
            // Include these as-is in the result if we haven't started type content yet
            if !found_type_content {
                result.push(line.to_string());
            }
            continue;
        }

        // Start capturing all content after imports as the type definition
        if !found_type_content {
            found_type_content = true;
        }
        
        result.push(line.to_string());
    }

    // Combine imports and type definition
    let mut final_result = imports.clone();
    if !final_result.is_empty() && !result.is_empty() {
        final_result.push(String::new()); // Add empty line between imports and type
    }
    final_result.extend(result);

    tracing::info!(
        "Final result for '{}': {} imports, {} total lines",
        type_name,
        imports.len(),
        final_result.len()
    );
    if !imports.is_empty() {
        tracing::info!("Imports being added: {:?}", imports);
    }

    let mut final_content = final_result.join("\n");

    // Remove trailing commas from the extracted type definition
    // This handles cases where the module format includes trailing commas
    // but individual files should not have them
    if final_content.ends_with("},") {
        final_content = final_content.trim_end_matches(',').to_string();
    }

    // Record extraction attempt for debugging
    if let Some(debug) = debug {
        let attempt = ExtractionAttempt {
            type_name: type_name.to_string(),
            module_name: "".to_string(), // Will be filled in by caller if needed
            extraction_strategy: "single-type".to_string(),
            imports_from_map,
            imports_found_in_content: imports_from_content,
            final_imports_used: imports,
            content_preview: final_content.chars().take(200).collect(),
            success: !final_content.is_empty(),
        };
        debug.record_extraction(attempt);
    }

    final_content
}

/// Extract a specific type definition from a module that contains multiple types  
fn extract_type_from_module(
    module_content: &str,
    type_name: &str,
    type_import_map: Option<&amalgam_codegen::nickel::TypeImportMap>,
    debug: Option<&mut ImportExtractionDebug>,
) -> String {
    // For multi-type modules, we extract the specific type with its definition
    // and wrap it appropriately
    extract_single_type_from_module(module_content, type_name, type_import_map, debug)
}

#[cfg(test)]
fn sanitize_name(name: &str) -> String {
    name.replace(['-', '.'], "_")
        .to_lowercase()
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect::<String>()
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

// Transform Type::Reference values using the provided mappings
// Alias for tests
#[cfg(test)]
fn capitalize(s: &str) -> String {
    capitalize_first(s)
}

fn needs_k8s_imports(ty: &Type) -> bool {
    // Check if the type references k8s.io types
    // This is a simplified check - would need more sophisticated analysis
    match ty {
        Type::Reference { name, module } => {
            name.contains("k8s.io")
                || name.contains("ObjectMeta")
                || module.as_ref().is_some_and(|m| m.contains("k8s.io"))
        }
        Type::Record { fields, .. } => fields.values().any(|field| needs_k8s_imports(&field.ty)),
        Type::Array(inner) => needs_k8s_imports(inner),
        Type::Optional(inner) => needs_k8s_imports(inner),
        Type::Union { types, .. } => types.iter().any(needs_k8s_imports),
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crd::{CRDMetadata, CRDNames, CRDSchema, CRDSpec, CRDVersion};
    use pretty_assertions::assert_eq;

    fn sample_crd(group: &str, version: &str, kind: &str) -> CRD {
        CRD {
            api_version: "apiextensions.k8s.io/v1".to_string(),
            kind: "CustomResourceDefinition".to_string(),
            metadata: CRDMetadata {
                name: format!("{}.{}", kind.to_lowercase(), group),
            },
            spec: CRDSpec {
                group: group.to_string(),
                names: CRDNames {
                    kind: kind.to_string(),
                    plural: format!("{}s", kind.to_lowercase()),
                    singular: kind.to_lowercase(),
                },
                versions: vec![CRDVersion {
                    name: version.to_string(),
                    served: true,
                    storage: true,
                    schema: Some(CRDSchema {
                        openapi_v3_schema: serde_json::json!({
                            "type": "object",
                            "properties": {
                                "spec": {
                                    "type": "object",
                                    "properties": {
                                        "field1": {"type": "string"},
                                        "field2": {"type": "integer"}
                                    }
                                }
                            }
                        }),
                    }),
                }],
            },
        }
    }

    #[test]
    fn test_package_generator_basic() {
        let mut generator =
            PackageGenerator::new("test-package".to_string(), PathBuf::from("/tmp/test"));

        generator.add_crd(sample_crd("example.io", "v1", "Widget"));

        let package = generator.generate_package().unwrap();

        assert_eq!(package.name, "test-package");
        assert!(package.groups().contains(&"example.io".to_string()));
    }

    #[test]
    fn test_sanitize_name_function() {
        assert_eq!(super::sanitize_name("some-name"), "some_name");
        assert_eq!(super::sanitize_name("name.with.dots"), "name_with_dots");
        assert_eq!(super::sanitize_name("UPPERCASE"), "uppercase");
    }

    #[test]
    fn test_capitalize_function() {
        assert_eq!(super::capitalize("widget"), "Widget");
        assert_eq!(super::capitalize(""), "");
    }
}
