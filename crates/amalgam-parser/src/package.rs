//! Package-based CRD importing (similar to CUE's approach)

use crate::{
    crd::{CRDParser, CRD},
    ParserError,
};
use amalgam_codegen::{
    nickel_package::{NickelPackageConfig, NickelPackageGenerator, PackageDependency},
    Codegen,
};
use amalgam_core::{
    ir::{Module, TypeDefinition, IR},
    types::Type,
};
use std::collections::HashMap;
use std::path::PathBuf;

pub struct PackageGenerator {
    crds: Vec<CRD>,
    package_name: String,
    _base_path: PathBuf,
}

impl PackageGenerator {
    pub fn new(package_name: String, base_path: PathBuf) -> Self {
        Self {
            crds: Vec::new(),
            package_name,
            _base_path: base_path,
        }
    }

    pub fn add_crd(&mut self, crd: CRD) {
        self.crds.push(crd);
    }

    pub fn add_crds(&mut self, crds: Vec<CRD>) {
        self.crds.extend(crds);
    }

    /// Generate a package structure similar to CUE's approach
    /// Creates a directory structure like:
    /// ```text
    /// package_name/
    ///   ├── mod.ncl                                    # Main module
    ///   ├── apiextensions.crossplane.io/
    ///   │   ├── mod.ncl                               # Group module
    ///   │   ├── v1/
    ///   │   │   ├── mod.ncl                           # Version module
    ///   │   │   ├── composition.ncl                   # Type definition
    ///   │   │   └── compositeresourcedefinition.ncl
    ///   │   └── v1beta1/
    ///   │       └── ...
    ///   └── pkg.crossplane.io/
    ///       └── ...
    /// ```
    pub fn generate_package(&self) -> Result<NamespacedPackage, ParserError> {
        let mut package = NamespacedPackage::new(self.package_name.clone());

        // Group CRDs by group, version, and kind
        for crd in &self.crds {
            let group = &crd.spec.group;
            let kind_lowercase = crd.spec.names.kind.to_lowercase();
            let _kind_original = crd.spec.names.kind.clone();

            for version in &crd.spec.versions {
                if !version.served {
                    continue; // Skip non-served versions
                }

                // Parse the CRD for this specific version
                let parser = CRDParser::new();
                let ir = parser.parse_version(crd, &version.name)?;

                // Extract the type definition for this version
                if let Some(module) = ir.modules.first() {
                    for type_def in &module.types {
                        // Store by group/version/kind structure with lowercase key
                        // but preserve original casing in the type definition
                        package.add_type(
                            group.clone(),
                            version.name.clone(),
                            kind_lowercase.clone(),
                            type_def.clone(),
                        );
                    }
                }
            }
        }

        Ok(package)
    }
}

/// Represents a package organized by group/version/kind
pub struct NamespacedPackage {
    pub name: String,
    /// group -> version -> kind -> TypeDefinition
    pub types: HashMap<String, HashMap<String, HashMap<String, TypeDefinition>>>,
}

impl NamespacedPackage {
    pub fn new(name: String) -> Self {
        Self {
            name,
            types: HashMap::new(),
        }
    }

    pub fn add_type(
        &mut self,
        group: String,
        version: String,
        kind: String,
        type_def: TypeDefinition,
    ) {
        self.types
            .entry(group)
            .or_default()
            .entry(version)
            .or_default()
            .insert(kind, type_def);
    }

    /// Generate the main module file
    pub fn generate_main_module(&self) -> String {
        let mut content = String::new();
        content.push_str(&format!("# {} - Kubernetes CRD types\n", self.name));
        content.push_str("# Auto-generated by amalgam\n");
        content.push_str("# Structure: group/version/kind\n\n");
        content.push_str("{\n");

        // Sort groups for consistent output
        let mut groups: Vec<_> = self.types.keys().collect();
        groups.sort();

        for group in groups {
            let safe_group = group.replace(['.', '-'], "_");
            content.push_str(&format!(
                "  {} = import \"./{}/mod.ncl\",\n",
                safe_group, group
            ));
        }

        content.push_str("}\n");
        content
    }

    /// Generate a group-level module file
    pub fn generate_group_module(&self, group: &str) -> Option<String> {
        self.types.get(group).map(|versions| {
            let mut content = String::new();
            content.push_str(&format!("# {} group\n", group));
            content.push_str("# Auto-generated by amalgam\n\n");
            content.push_str("{\n");

            // Sort versions for consistent output
            let mut version_list: Vec<_> = versions.keys().collect();
            version_list.sort();

            for version in version_list {
                content.push_str(&format!(
                    "  {} = import \"./{}/mod.ncl\",\n",
                    version, version
                ));
            }

            content.push_str("}\n");
            content
        })
    }

    /// Generate a version-level module file for a group
    pub fn generate_version_module(&self, group: &str, version: &str) -> Option<String> {
        self.types.get(group).and_then(|versions| {
            versions.get(version).map(|kinds| {
                let mut content = String::new();
                content.push_str(&format!("# {}/{} types\n", group, version));
                content.push_str("# Auto-generated by amalgam\n\n");
                content.push_str("{\n");

                // Sort kinds for consistent output
                let mut kind_list: Vec<_> = kinds.keys().collect();
                kind_list.sort();

                for kind in kind_list {
                    // Use the actual type name from the TypeDefinition
                    let type_name = if let Some(type_def) = kinds.get(kind) {
                        type_def.name.clone()
                    } else {
                        capitalize_first(kind)
                    };
                    content.push_str(&format!("  {} = import \"./{}.ncl\",\n", type_name, kind));
                }

                content.push_str("}\n");
                content
            })
        })
    }

    /// Generate all files for a version using unified IR pipeline with walkers
    #[tracing::instrument(skip(self), fields(group = %group, version = %version))]
    pub fn generate_version_files(&self, group: &str, version: &str) -> HashMap<String, String> {
        tracing::info!("generate_version_files called for {}/{}", group, version);
        let mut files = HashMap::new();

        // Get types for this version
        let types = match self.types.get(group).and_then(|v| v.get(version)) {
            Some(types) => types,
            None => return files,
        };

        // Step 1: Build type registry using the walker adapter
        let registry = match crate::package_walker::PackageWalkerAdapter::build_registry(
            types, group, version,
        ) {
            Ok(reg) => reg,
            Err(e) => {
                tracing::error!("Failed to build type registry: {}", e);
                return files;
            }
        };

        // Step 2: Build dependency graph
        let deps = crate::package_walker::PackageWalkerAdapter::build_dependencies(&registry);

        // Step 3: Generate complete IR with imports
        let ir = match crate::package_walker::PackageWalkerAdapter::generate_ir(
            registry, deps, group, version,
        ) {
            Ok(ir) => ir,
            Err(e) => {
                tracing::error!("Failed to generate IR: {}", e);
                return files;
            }
        };

        // Step 4: Generate files from IR using codegen
        let mut codegen = amalgam_codegen::nickel::NickelCodegen::new();

        // Generate a file for each module in the IR
        for module in &ir.modules {
            // Extract type name from module name (last component)
            let type_name = module.name.rsplit('.').next().unwrap_or(&module.name);

            // Create a single-module IR for this type
            let mut single_ir = IR::new();
            single_ir.add_module(module.clone());

            // Generate the Nickel code
            let generated = codegen
                .generate(&single_ir)
                .unwrap_or_else(|e| format!("# Error generating type: {}\n", e));

            files.insert(format!("{}.ncl", type_name), generated);
        }

        // Generate mod.ncl for this version
        if let Some(mod_content) = self.generate_version_module(group, version) {
            files.insert("mod.ncl".to_string(), mod_content);
        }

        files
    }

    /// Get all groups in the package
    pub fn groups(&self) -> Vec<String> {
        let mut groups: Vec<_> = self.types.keys().cloned().collect();
        groups.sort();
        groups
    }

    /// Get all versions for a group
    pub fn versions(&self, group: &str) -> Vec<String> {
        self.types
            .get(group)
            .map(|versions| {
                let mut version_list: Vec<_> = versions.keys().cloned().collect();
                version_list.sort();
                version_list
            })
            .unwrap_or_default()
    }

    /// Get all kinds for a group/version
    pub fn kinds(&self, group: &str, version: &str) -> Vec<String> {
        self.types
            .get(group)
            .and_then(|versions| {
                versions.get(version).map(|kinds| {
                    let mut kind_list: Vec<_> = kinds.keys().cloned().collect();
                    kind_list.sort();
                    kind_list
                })
            })
            .unwrap_or_default()
    }

    /// Generate a Nickel package manifest (Nickel-pkg.ncl)
    pub fn generate_nickel_manifest(&self, config: Option<NickelPackageConfig>) -> String {
        let config = config.unwrap_or_else(|| NickelPackageConfig {
            name: self.name.clone(),
            description: format!("Generated type definitions for {}", self.name),
            version: "0.1.0".to_string(),
            minimal_nickel_version: "1.9.0".to_string(),
            authors: vec!["amalgam".to_string()],
            license: "Apache-2.0".to_string(),
            keywords: {
                let mut keywords = vec!["kubernetes".to_string(), "types".to_string()];
                // Add groups as keywords
                for group in self.groups() {
                    keywords.push(group.replace('.', "-"));
                }
                keywords
            },
        });

        let generator = NickelPackageGenerator::new(config);

        // Detect if we need k8s.io as a dependency
        let mut dependencies = HashMap::new();
        if self.has_k8s_references() {
            // Add k8s.io as a path dependency (assuming it's in a sibling directory)
            dependencies.insert(
                "k8s_io".to_string(),
                PackageDependency::Path(PathBuf::from("../k8s_io")),
            );
        }

        // Convert our types to modules for the generator
        let modules: Vec<Module> = self
            .groups()
            .into_iter()
            .flat_map(|group| {
                self.versions(&group)
                    .into_iter()
                    .map(move |version| Module {
                        name: format!("{}.{}", group, version),
                        imports: Vec::new(),
                        types: Vec::new(),
                        constants: Vec::new(),
                        metadata: Default::default(),
                    })
            })
            .collect();

        generator
            .generate_manifest(&modules, dependencies)
            .unwrap_or_else(|e| format!("# Error generating manifest: {}\n", e))
    }

    /// Check if any types reference k8s.io types
    fn has_k8s_references(&self) -> bool {
        for versions in self.types.values() {
            for kinds in versions.values() {
                for type_def in kinds.values() {
                    if needs_k8s_imports(&type_def.ty) {
                        return true;
                    }
                }
            }
        }
        false
    }
}

#[allow(dead_code)]
fn sanitize_name(name: &str) -> String {
    name.replace(['-', '.'], "_")
        .to_lowercase()
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect::<String>()
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

// Transform Type::Reference values using the provided mappings
// Alias for tests
#[allow(dead_code)]
fn capitalize(s: &str) -> String {
    capitalize_first(s)
}

#[allow(dead_code)]
fn needs_k8s_imports(ty: &Type) -> bool {
    // Check if the type references k8s.io types
    // This is a simplified check - would need more sophisticated analysis
    match ty {
        Type::Reference { name, module } => {
            name.contains("k8s.io")
                || name.contains("ObjectMeta")
                || module.as_ref().is_some_and(|m| m.contains("k8s.io"))
        }
        Type::Record { fields, .. } => fields.values().any(|field| needs_k8s_imports(&field.ty)),
        Type::Array(inner) => needs_k8s_imports(inner),
        Type::Optional(inner) => needs_k8s_imports(inner),
        Type::Union { types, .. } => types.iter().any(needs_k8s_imports),
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crd::{CRDMetadata, CRDNames, CRDSchema, CRDSpec, CRDVersion};
    use pretty_assertions::assert_eq;

    fn sample_crd(group: &str, version: &str, kind: &str) -> CRD {
        CRD {
            api_version: "apiextensions.k8s.io/v1".to_string(),
            kind: "CustomResourceDefinition".to_string(),
            metadata: CRDMetadata {
                name: format!("{}.{}", kind.to_lowercase(), group),
            },
            spec: CRDSpec {
                group: group.to_string(),
                names: CRDNames {
                    kind: kind.to_string(),
                    plural: format!("{}s", kind.to_lowercase()),
                    singular: kind.to_lowercase(),
                },
                versions: vec![CRDVersion {
                    name: version.to_string(),
                    served: true,
                    storage: true,
                    schema: Some(CRDSchema {
                        openapi_v3_schema: serde_json::json!({
                            "type": "object",
                            "properties": {
                                "spec": {
                                    "type": "object",
                                    "properties": {
                                        "field1": {"type": "string"},
                                        "field2": {"type": "integer"}
                                    }
                                }
                            }
                        }),
                    }),
                }],
            },
        }
    }

    #[test]
    fn test_package_generator_basic() {
        let mut generator =
            PackageGenerator::new("test-package".to_string(), PathBuf::from("/tmp/test"));

        generator.add_crd(sample_crd("example.io", "v1", "Widget"));

        let package = generator.generate_package().unwrap();

        assert_eq!(package.name, "test-package");
        assert!(package.groups().contains(&"example.io".to_string()));
    }

    #[test]
    fn test_sanitize_name_function() {
        assert_eq!(super::sanitize_name("some-name"), "some_name");
        assert_eq!(super::sanitize_name("name.with.dots"), "name_with_dots");
        assert_eq!(super::sanitize_name("UPPERCASE"), "uppercase");
    }

    #[test]
    fn test_capitalize_function() {
        assert_eq!(super::capitalize("widget"), "Widget");
        assert_eq!(super::capitalize(""), "");
    }
}
