//! Package-based CRD importing (similar to CUE's approach)

use crate::{crd::{CRD, CRDParser}, ParserError, imports::ImportResolver};
use amalgam_core::{ir::{IR, Module, TypeDefinition, Import}, types::Type};
use amalgam_codegen::Codegen;
use std::collections::HashMap;
use std::path::PathBuf;

pub struct PackageGenerator {
    crds: Vec<CRD>,
    package_name: String,
    _base_path: PathBuf,
}

impl PackageGenerator {
    pub fn new(package_name: String, base_path: PathBuf) -> Self {
        Self {
            crds: Vec::new(),
            package_name,
            _base_path: base_path,
        }
    }
    
    pub fn add_crd(&mut self, crd: CRD) {
        self.crds.push(crd);
    }
    
    pub fn add_crds(&mut self, crds: Vec<CRD>) {
        self.crds.extend(crds);
    }
    
    /// Generate a package structure similar to CUE's approach
    /// Creates a directory structure like:
    /// ```text
    /// package_name/
    ///   ├── mod.ncl                                    # Main module
    ///   ├── apiextensions.crossplane.io/
    ///   │   ├── mod.ncl                               # Group module
    ///   │   ├── v1/
    ///   │   │   ├── mod.ncl                           # Version module
    ///   │   │   ├── composition.ncl                   # Type definition
    ///   │   │   └── compositeresourcedefinition.ncl
    ///   │   └── v1beta1/
    ///   │       └── ...
    ///   └── pkg.crossplane.io/
    ///       └── ...
    /// ```
    pub fn generate_package(&self) -> Result<NamespacedPackage, ParserError> {
        let mut package = NamespacedPackage::new(self.package_name.clone());
        
        // Group CRDs by group, version, and kind
        for crd in &self.crds {
            let group = &crd.spec.group;
            let kind_lowercase = crd.spec.names.kind.to_lowercase();
            let _kind_original = crd.spec.names.kind.clone();
            
            for version in &crd.spec.versions {
                if !version.served {
                    continue; // Skip non-served versions
                }
                
                // Parse the CRD for this specific version
                let parser = CRDParser::new();
                let ir = parser.parse_version(crd, &version.name)?;
                
                // Extract the type definition for this version
                if let Some(module) = ir.modules.first() {
                    for type_def in &module.types {
                        // Store by group/version/kind structure with lowercase key
                        // but preserve original casing in the type definition
                        package.add_type(
                            group.clone(),
                            version.name.clone(),
                            kind_lowercase.clone(),
                            type_def.clone(),
                        );
                    }
                }
            }
        }
        
        Ok(package)
    }
}

/// Represents a package organized by group/version/kind
pub struct NamespacedPackage {
    pub name: String,
    /// group -> version -> kind -> TypeDefinition
    pub types: HashMap<String, HashMap<String, HashMap<String, TypeDefinition>>>,
}

impl NamespacedPackage {
    pub fn new(name: String) -> Self {
        Self {
            name,
            types: HashMap::new(),
        }
    }
    
    pub fn add_type(&mut self, group: String, version: String, kind: String, type_def: TypeDefinition) {
        self.types
            .entry(group)
            .or_insert_with(HashMap::new)
            .entry(version)
            .or_insert_with(HashMap::new)
            .insert(kind, type_def);
    }
    
    /// Generate the main module file
    pub fn generate_main_module(&self) -> String {
        let mut content = String::new();
        content.push_str(&format!("# {} - Kubernetes CRD types\n", self.name));
        content.push_str("# Auto-generated by amalgam\n");
        content.push_str("# Structure: group/version/kind\n\n");
        content.push_str("{\n");
        
        // Sort groups for consistent output
        let mut groups: Vec<_> = self.types.keys().collect();
        groups.sort();
        
        for group in groups {
            let safe_group = group.replace('.', "_").replace('-', "_");
            content.push_str(&format!("  {} = import \"./{}/mod.ncl\",\n", safe_group, group));
        }
        
        content.push_str("}\n");
        content
    }
    
    /// Generate a group-level module file
    pub fn generate_group_module(&self, group: &str) -> Option<String> {
        self.types.get(group).map(|versions| {
            let mut content = String::new();
            content.push_str(&format!("# {} group\n", group));
            content.push_str("# Auto-generated by amalgam\n\n");
            content.push_str("{\n");
            
            // Sort versions for consistent output
            let mut version_list: Vec<_> = versions.keys().collect();
            version_list.sort();
            
            for version in version_list {
                content.push_str(&format!("  {} = import \"./{}/mod.ncl\",\n", version, version));
            }
            
            content.push_str("}\n");
            content
        })
    }
    
    /// Generate a version-level module file for a group
    pub fn generate_version_module(&self, group: &str, version: &str) -> Option<String> {
        self.types.get(group).and_then(|versions| {
            versions.get(version).map(|kinds| {
                let mut content = String::new();
                content.push_str(&format!("# {}/{} types\n", group, version));
                content.push_str("# Auto-generated by amalgam\n\n");
                content.push_str("{\n");
                
                // Sort kinds for consistent output
                let mut kind_list: Vec<_> = kinds.keys().collect();
                kind_list.sort();
                
                for kind in kind_list {
                    // Use the actual type name from the TypeDefinition
                    let type_name = if let Some(type_def) = kinds.get(kind) {
                        type_def.name.clone()
                    } else {
                        capitalize_first(kind)
                    };
                    content.push_str(&format!("  {} = import \"./{}.ncl\",\n", type_name, kind));
                }
                
                content.push_str("}\n");
                content
            })
        })
    }
    
    /// Generate a kind-specific file
    pub fn generate_kind_file(&self, group: &str, version: &str, kind: &str) -> Option<String> {
        self.types.get(group).and_then(|versions| {
            versions.get(version).and_then(|kinds| {
                kinds.get(kind).map(|type_def| {
                    // Use the nickel codegen to generate the type
                    let mut ir = IR::new();
                    let mut module = Module {
                        name: format!("{}.{}", kind, group),
                        imports: Vec::new(),
                        types: vec![type_def.clone()],
                        constants: Vec::new(),
                        metadata: Default::default(),
                    };
                    
                    // Analyze the type for external references and add imports
                    let mut import_resolver = ImportResolver::new();
                    import_resolver.analyze_type(&type_def.ty);
                    
                    // Generate imports based on detected references
                    for type_ref in import_resolver.references() {
                        // Convert TypeReference to Import
                        let import_path = type_ref.import_path(group, version);
                        let alias = Some(type_ref.module_alias());
                        
                        tracing::debug!(
                            "Adding import for {:?} -> path: {}, alias: {:?}", 
                            type_ref, import_path, alias
                        );
                        
                        module.imports.push(Import {
                            path: import_path,
                            alias,
                            items: vec![], // Empty items means import the whole module
                        });
                    }
                    
                    tracing::debug!("Module {} has {} imports", module.name, module.imports.len());
                    ir.add_module(module);
                    
                    // Generate the Nickel code
                    let mut codegen = amalgam_codegen::nickel::NickelCodegen::new();
                    codegen.generate(&ir).unwrap_or_else(|e| {
                        format!("# Error generating type: {}\n", e)
                    })
                })
            })
        })
    }
    
    /// Get all groups in the package
    pub fn groups(&self) -> Vec<String> {
        let mut groups: Vec<_> = self.types.keys().cloned().collect();
        groups.sort();
        groups
    }
    
    /// Get all versions for a group
    pub fn versions(&self, group: &str) -> Vec<String> {
        self.types.get(group).map(|versions| {
            let mut version_list: Vec<_> = versions.keys().cloned().collect();
            version_list.sort();
            version_list
        }).unwrap_or_default()
    }
    
    /// Get all kinds for a group/version
    pub fn kinds(&self, group: &str, version: &str) -> Vec<String> {
        self.types.get(group).and_then(|versions| {
            versions.get(version).map(|kinds| {
                let mut kind_list: Vec<_> = kinds.keys().cloned().collect();
                kind_list.sort();
                kind_list
            })
        }).unwrap_or_default()
    }
}

#[allow(dead_code)]
fn sanitize_name(name: &str) -> String {
    name.replace('-', "_")
        .replace('.', "_")
        .to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
        .collect::<String>()
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

// Alias for tests
#[allow(dead_code)]
fn capitalize(s: &str) -> String {
    capitalize_first(s)
}

#[allow(dead_code)]
fn needs_k8s_imports(ty: &Type) -> bool {
    // Check if the type references k8s.io types
    // This is a simplified check - would need more sophisticated analysis
    match ty {
        Type::Reference(name) => name.contains("k8s.io") || name.contains("ObjectMeta"),
        Type::Record { fields, .. } => {
            fields.values().any(|field| needs_k8s_imports(&field.ty))
        }
        Type::Array(inner) => needs_k8s_imports(inner),
        Type::Optional(inner) => needs_k8s_imports(inner),
        Type::Union(types) => types.iter().any(needs_k8s_imports),
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crd::{CRDSpec, CRDNames, CRDVersion, CRDSchema, CRDMetadata};
    use pretty_assertions::assert_eq;

    fn sample_crd(group: &str, version: &str, kind: &str) -> CRD {
        CRD {
            api_version: "apiextensions.k8s.io/v1".to_string(),
            kind: "CustomResourceDefinition".to_string(),
            metadata: CRDMetadata {
                name: format!("{}.{}", kind.to_lowercase(), group),
            },
            spec: CRDSpec {
                group: group.to_string(),
                names: CRDNames {
                    kind: kind.to_string(),
                    plural: format!("{}s", kind.to_lowercase()),
                    singular: kind.to_lowercase(),
                },
                versions: vec![CRDVersion {
                    name: version.to_string(),
                    served: true,
                    storage: true,
                    schema: Some(CRDSchema {
                        openapi_v3_schema: serde_json::json!({
                            "type": "object",
                            "properties": {
                                "spec": {
                                    "type": "object",
                                    "properties": {
                                        "field1": {"type": "string"},
                                        "field2": {"type": "integer"}
                                    }
                                }
                            }
                        }),
                    }),
                }],
            },
        }
    }

    #[test]
    fn test_package_generator_basic() {
        let mut generator = PackageGenerator::new(
            "test-package".to_string(),
            PathBuf::from("/tmp/test"),
        );
        
        generator.add_crd(sample_crd("example.io", "v1", "Widget"));
        
        let package = generator.generate_package().unwrap();
        
        assert_eq!(package.name, "test-package");
        assert!(package.groups().contains(&"example.io".to_string()));
    }

    #[test]
    fn test_sanitize_name_function() {
        assert_eq!(super::sanitize_name("some-name"), "some_name");
        assert_eq!(super::sanitize_name("name.with.dots"), "name_with_dots");
        assert_eq!(super::sanitize_name("UPPERCASE"), "uppercase");
    }

    #[test]
    fn test_capitalize_function() {
        assert_eq!(super::capitalize("widget"), "Widget");
        assert_eq!(super::capitalize(""), "");
    }
}