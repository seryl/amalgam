//! Package-based CRD importing (similar to CUE's approach)

use crate::{
    crd::{CRDParser, CRD},
    imports::{ImportResolver, TypeReference},
    ParserError,
};
use amalgam_codegen::{
    nickel_package::{NickelPackageConfig, NickelPackageGenerator, PackageDependency},
    Codegen,
};
use amalgam_core::{
    ir::{Import, Module, TypeDefinition, IR},
    types::Type,
};
use std::collections::HashMap;
use std::path::PathBuf;

pub struct PackageGenerator {
    crds: Vec<CRD>,
    package_name: String,
    _base_path: PathBuf,
}

impl PackageGenerator {
    pub fn new(package_name: String, base_path: PathBuf) -> Self {
        Self {
            crds: Vec::new(),
            package_name,
            _base_path: base_path,
        }
    }

    pub fn add_crd(&mut self, crd: CRD) {
        self.crds.push(crd);
    }

    pub fn add_crds(&mut self, crds: Vec<CRD>) {
        self.crds.extend(crds);
    }

    /// Generate a package structure similar to CUE's approach
    /// Creates a directory structure like:
    /// ```text
    /// package_name/
    ///   ├── mod.ncl                                    # Main module
    ///   ├── apiextensions.crossplane.io/
    ///   │   ├── mod.ncl                               # Group module
    ///   │   ├── v1/
    ///   │   │   ├── mod.ncl                           # Version module
    ///   │   │   ├── composition.ncl                   # Type definition
    ///   │   │   └── compositeresourcedefinition.ncl
    ///   │   └── v1beta1/
    ///   │       └── ...
    ///   └── pkg.crossplane.io/
    ///       └── ...
    /// ```
    pub fn generate_package(&self) -> Result<NamespacedPackage, ParserError> {
        let mut package = NamespacedPackage::new(self.package_name.clone());

        // Group CRDs by group, version, and kind
        for crd in &self.crds {
            let group = &crd.spec.group;
            let kind_lowercase = crd.spec.names.kind.to_lowercase();
            let _kind_original = crd.spec.names.kind.clone();

            for version in &crd.spec.versions {
                if !version.served {
                    continue; // Skip non-served versions
                }

                // Parse the CRD for this specific version
                let parser = CRDParser::new();
                let ir = parser.parse_version(crd, &version.name)?;

                // Extract the type definition for this version
                if let Some(module) = ir.modules.first() {
                    for type_def in &module.types {
                        // Store by group/version/kind structure with lowercase key
                        // but preserve original casing in the type definition
                        package.add_type(
                            group.clone(),
                            version.name.clone(),
                            kind_lowercase.clone(),
                            type_def.clone(),
                        );
                    }
                }
            }
        }

        Ok(package)
    }
}

/// Represents a package organized by group/version/kind
pub struct NamespacedPackage {
    pub name: String,
    /// group -> version -> kind -> TypeDefinition
    pub types: HashMap<String, HashMap<String, HashMap<String, TypeDefinition>>>,
}

impl NamespacedPackage {
    pub fn new(name: String) -> Self {
        Self {
            name,
            types: HashMap::new(),
        }
    }

    pub fn add_type(
        &mut self,
        group: String,
        version: String,
        kind: String,
        type_def: TypeDefinition,
    ) {
        self.types
            .entry(group)
            .or_default()
            .entry(version)
            .or_default()
            .insert(kind, type_def);
    }

    /// Generate the main module file
    pub fn generate_main_module(&self) -> String {
        let mut content = String::new();
        content.push_str(&format!("# {} - Kubernetes CRD types\n", self.name));
        content.push_str("# Auto-generated by amalgam\n");
        content.push_str("# Structure: group/version/kind\n\n");
        content.push_str("{\n");

        // Sort groups for consistent output
        let mut groups: Vec<_> = self.types.keys().collect();
        groups.sort();

        for group in groups {
            let safe_group = group.replace(['.', '-'], "_");
            content.push_str(&format!(
                "  {} = import \"./{}/mod.ncl\",\n",
                safe_group, group
            ));
        }

        content.push_str("}\n");
        content
    }

    /// Generate a group-level module file
    pub fn generate_group_module(&self, group: &str) -> Option<String> {
        self.types.get(group).map(|versions| {
            let mut content = String::new();
            content.push_str(&format!("# {} group\n", group));
            content.push_str("# Auto-generated by amalgam\n\n");
            content.push_str("{\n");

            // Sort versions for consistent output
            let mut version_list: Vec<_> = versions.keys().collect();
            version_list.sort();

            for version in version_list {
                content.push_str(&format!(
                    "  {} = import \"./{}/mod.ncl\",\n",
                    version, version
                ));
            }

            content.push_str("}\n");
            content
        })
    }

    /// Generate a version-level module file for a group
    pub fn generate_version_module(&self, group: &str, version: &str) -> Option<String> {
        self.types.get(group).and_then(|versions| {
            versions.get(version).map(|kinds| {
                let mut content = String::new();
                content.push_str(&format!("# {}/{} types\n", group, version));
                content.push_str("# Auto-generated by amalgam\n\n");
                content.push_str("{\n");

                // Sort kinds for consistent output
                let mut kind_list: Vec<_> = kinds.keys().collect();
                kind_list.sort();

                for kind in kind_list {
                    // Use the actual type name from the TypeDefinition
                    let type_name = if let Some(type_def) = kinds.get(kind) {
                        type_def.name.clone()
                    } else {
                        capitalize_first(kind)
                    };
                    content.push_str(&format!("  {} = import \"./{}.ncl\",\n", type_name, kind));
                }

                content.push_str("}\n");
                content
            })
        })
    }

    /// Generate a kind-specific file
    pub fn generate_kind_file(&self, group: &str, version: &str, kind: &str) -> Option<String> {
        self.types.get(group).and_then(|versions| {
            versions.get(version).and_then(|kinds| {
                kinds.get(kind).map(|type_def| {
                    // Use the nickel codegen to generate the type
                    let mut ir = IR::new();
                    let mut module = Module {
                        name: format!("{}.{}", kind, group),
                        imports: Vec::new(),
                        types: vec![type_def.clone()],
                        constants: Vec::new(),
                        metadata: Default::default(),
                    };

                    // Analyze the type for external references and add imports
                    let mut import_resolver = ImportResolver::new();
                    import_resolver.analyze_type(&type_def.ty);

                    // Build a mapping from full qualified names to alias.TypeName
                    let mut reference_mappings: HashMap<String, String> = HashMap::new();

                    // Group references by their import path to avoid duplicates
                    let mut imports_by_path: HashMap<String, Vec<TypeReference>> = HashMap::new();

                    for type_ref in import_resolver.references() {
                        let import_path = type_ref.import_path(group, version);
                        imports_by_path
                            .entry(import_path)
                            .or_default()
                            .push(type_ref.clone());
                    }

                    // Generate a single import for each unique path and build mappings
                    for (import_path, type_refs) in imports_by_path {
                        // Generate a proper alias for this import
                        let alias = if import_path.contains("k8s_io") {
                            // For k8s types, extract the filename as the basis for the alias
                            let filename = import_path
                                .trim_end_matches(".ncl")
                                .split('/')
                                .next_back()
                                .unwrap_or("unknown");
                            format!("k8s_io_{}", filename)
                        } else {
                            format!("import_{}", module.imports.len())
                        };

                        // Create mappings for all types from this import
                        for type_ref in &type_refs {
                            // Build the full qualified name that appears in Type::Reference
                            let full_name = if type_ref.group == "k8s.io" {
                                // For k8s types, construct the full io.k8s... name
                                if type_ref.kind == "ObjectMeta" || type_ref.kind == "ListMeta" {
                                    format!(
                                        "io.k8s.apimachinery.pkg.apis.meta.{}.{}",
                                        type_ref.version, type_ref.kind
                                    )
                                } else {
                                    format!(
                                        "io.k8s.api.core.{}.{}",
                                        type_ref.version, type_ref.kind
                                    )
                                }
                            } else {
                                // For other types, use a simpler format
                                format!("{}/{}.{}", type_ref.group, type_ref.version, type_ref.kind)
                            };

                            // Map to alias.TypeName
                            let mapped_name = format!("{}.{}", alias, type_ref.kind);
                            reference_mappings.insert(full_name, mapped_name);
                        }

                        tracing::debug!(
                            "Adding import: path={}, alias={}, types={:?}",
                            import_path,
                            alias,
                            type_refs.iter().map(|t| &t.kind).collect::<Vec<_>>()
                        );

                        module.imports.push(Import {
                            path: import_path,
                            alias: Some(alias),
                            items: vec![], // Empty items means import the whole module
                        });
                    }

                    // Transform the type definition to use the mapped references
                    let mut transformed_type_def = type_def.clone();
                    transform_type_references(&mut transformed_type_def.ty, &reference_mappings);

                    // Use the transformed type definition
                    module.types = vec![transformed_type_def];

                    tracing::debug!(
                        "Module {} has {} imports",
                        module.name,
                        module.imports.len()
                    );
                    ir.add_module(module);

                    // Generate the Nickel code with package mode
                    use amalgam_codegen::package_mode::PackageMode;
                    use std::path::PathBuf;

                    // Use analyzer-based package mode for automatic dependency detection
                    let manifest_path = PathBuf::from(".amalgam-manifest.toml");
                    let manifest = if manifest_path.exists() {
                        Some(&manifest_path)
                    } else {
                        None
                    };

                    let mut package_mode = PackageMode::new_with_analyzer(manifest);

                    // Analyze types to detect dependencies
                    let mut all_types: Vec<amalgam_core::types::Type> = Vec::new();
                    for module in &ir.modules {
                        for type_def in &module.types {
                            all_types.push(type_def.ty.clone());
                        }
                    }
                    package_mode.analyze_and_update_dependencies(&all_types, group);

                    let mut codegen = amalgam_codegen::nickel::NickelCodegen::new()
                        .with_package_mode(package_mode);
                    let mut generated = codegen
                        .generate(&ir)
                        .unwrap_or_else(|e| format!("# Error generating type: {}\n", e));

                    // For k8s.io packages, check for missing internal imports
                    if group == "k8s.io" || group.starts_with("io.k8s") {
                        use crate::k8s_imports::{find_k8s_type_references, fix_k8s_imports};
                        let type_refs = find_k8s_type_references(&type_def.ty);
                        if !type_refs.is_empty() {
                            generated = fix_k8s_imports(&generated, &type_refs, version);
                        }
                    }

                    generated
                })
            })
        })
    }

    /// Get all groups in the package
    pub fn groups(&self) -> Vec<String> {
        let mut groups: Vec<_> = self.types.keys().cloned().collect();
        groups.sort();
        groups
    }

    /// Get all versions for a group
    pub fn versions(&self, group: &str) -> Vec<String> {
        self.types
            .get(group)
            .map(|versions| {
                let mut version_list: Vec<_> = versions.keys().cloned().collect();
                version_list.sort();
                version_list
            })
            .unwrap_or_default()
    }

    /// Get all kinds for a group/version
    pub fn kinds(&self, group: &str, version: &str) -> Vec<String> {
        self.types
            .get(group)
            .and_then(|versions| {
                versions.get(version).map(|kinds| {
                    let mut kind_list: Vec<_> = kinds.keys().cloned().collect();
                    kind_list.sort();
                    kind_list
                })
            })
            .unwrap_or_default()
    }

    /// Generate a Nickel package manifest (Nickel-pkg.ncl)
    pub fn generate_nickel_manifest(&self, config: Option<NickelPackageConfig>) -> String {
        let config = config.unwrap_or_else(|| NickelPackageConfig {
            name: self.name.clone(),
            description: format!("Generated type definitions for {}", self.name),
            version: "0.1.0".to_string(),
            minimal_nickel_version: "1.9.0".to_string(),
            authors: vec!["amalgam".to_string()],
            license: "Apache-2.0".to_string(),
            keywords: {
                let mut keywords = vec!["kubernetes".to_string(), "types".to_string()];
                // Add groups as keywords
                for group in self.groups() {
                    keywords.push(group.replace('.', "-"));
                }
                keywords
            },
        });

        let generator = NickelPackageGenerator::new(config);

        // Detect if we need k8s.io as a dependency
        let mut dependencies = HashMap::new();
        if self.has_k8s_references() {
            // Add k8s.io as a path dependency (assuming it's in a sibling directory)
            dependencies.insert(
                "k8s_io".to_string(),
                PackageDependency::Path(PathBuf::from("../k8s_io")),
            );
        }

        // Convert our types to modules for the generator
        let modules: Vec<Module> = self
            .groups()
            .into_iter()
            .flat_map(|group| {
                self.versions(&group)
                    .into_iter()
                    .map(move |version| Module {
                        name: format!("{}.{}", group, version),
                        imports: Vec::new(),
                        types: Vec::new(),
                        constants: Vec::new(),
                        metadata: Default::default(),
                    })
            })
            .collect();

        generator
            .generate_manifest(&modules, dependencies)
            .unwrap_or_else(|e| format!("# Error generating manifest: {}\n", e))
    }

    /// Check if any types reference k8s.io types
    fn has_k8s_references(&self) -> bool {
        for versions in self.types.values() {
            for kinds in versions.values() {
                for type_def in kinds.values() {
                    if needs_k8s_imports(&type_def.ty) {
                        return true;
                    }
                }
            }
        }
        false
    }
}

#[allow(dead_code)]
fn sanitize_name(name: &str) -> String {
    name.replace(['-', '.'], "_")
        .to_lowercase()
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect::<String>()
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

/// Transform Type::Reference values using the provided mappings
fn transform_type_references(ty: &mut Type, mappings: &HashMap<String, String>) {
    match ty {
        Type::Reference(name) => {
            // Check if we have a mapping for this reference
            if let Some(mapped) = mappings.get(name) {
                *name = mapped.clone();
            }
        }
        Type::Array(inner) => transform_type_references(inner, mappings),
        Type::Optional(inner) => transform_type_references(inner, mappings),
        Type::Map { value, .. } => transform_type_references(value, mappings),
        Type::Record { fields, .. } => {
            for field in fields.values_mut() {
                transform_type_references(&mut field.ty, mappings);
            }
        }
        Type::Union(types) => {
            for ty in types {
                transform_type_references(ty, mappings);
            }
        }
        Type::TaggedUnion { variants, .. } => {
            for variant_type in variants.values_mut() {
                transform_type_references(variant_type, mappings);
            }
        }
        _ => {} // Other types don't contain references
    }
}

// Alias for tests
#[allow(dead_code)]
fn capitalize(s: &str) -> String {
    capitalize_first(s)
}

#[allow(dead_code)]
fn needs_k8s_imports(ty: &Type) -> bool {
    // Check if the type references k8s.io types
    // This is a simplified check - would need more sophisticated analysis
    match ty {
        Type::Reference(name) => name.contains("k8s.io") || name.contains("ObjectMeta"),
        Type::Record { fields, .. } => fields.values().any(|field| needs_k8s_imports(&field.ty)),
        Type::Array(inner) => needs_k8s_imports(inner),
        Type::Optional(inner) => needs_k8s_imports(inner),
        Type::Union(types) => types.iter().any(needs_k8s_imports),
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crd::{CRDMetadata, CRDNames, CRDSchema, CRDSpec, CRDVersion};
    use pretty_assertions::assert_eq;

    fn sample_crd(group: &str, version: &str, kind: &str) -> CRD {
        CRD {
            api_version: "apiextensions.k8s.io/v1".to_string(),
            kind: "CustomResourceDefinition".to_string(),
            metadata: CRDMetadata {
                name: format!("{}.{}", kind.to_lowercase(), group),
            },
            spec: CRDSpec {
                group: group.to_string(),
                names: CRDNames {
                    kind: kind.to_string(),
                    plural: format!("{}s", kind.to_lowercase()),
                    singular: kind.to_lowercase(),
                },
                versions: vec![CRDVersion {
                    name: version.to_string(),
                    served: true,
                    storage: true,
                    schema: Some(CRDSchema {
                        openapi_v3_schema: serde_json::json!({
                            "type": "object",
                            "properties": {
                                "spec": {
                                    "type": "object",
                                    "properties": {
                                        "field1": {"type": "string"},
                                        "field2": {"type": "integer"}
                                    }
                                }
                            }
                        }),
                    }),
                }],
            },
        }
    }

    #[test]
    fn test_package_generator_basic() {
        let mut generator =
            PackageGenerator::new("test-package".to_string(), PathBuf::from("/tmp/test"));

        generator.add_crd(sample_crd("example.io", "v1", "Widget"));

        let package = generator.generate_package().unwrap();

        assert_eq!(package.name, "test-package");
        assert!(package.groups().contains(&"example.io".to_string()));
    }

    #[test]
    fn test_sanitize_name_function() {
        assert_eq!(super::sanitize_name("some-name"), "some_name");
        assert_eq!(super::sanitize_name("name.with.dots"), "name_with_dots");
        assert_eq!(super::sanitize_name("UPPERCASE"), "uppercase");
    }

    #[test]
    fn test_capitalize_function() {
        assert_eq!(super::capitalize("widget"), "Widget");
        assert_eq!(super::capitalize(""), "");
    }
}
