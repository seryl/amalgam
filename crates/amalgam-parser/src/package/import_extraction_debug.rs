use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Debug structure to track the entire import extraction pipeline
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportExtractionDebug {
    /// Stage 1: What imports were generated by NickelCodegen for each type
    pub codegen_imports: HashMap<String, Vec<String>>,

    /// Stage 2: Module content generated (first 500 chars)
    pub module_content_preview: String,

    /// Stage 3: For each type extraction attempt
    pub extraction_attempts: Vec<ExtractionAttempt>,

    /// Stage 4: Final files generated with their content (first 500 chars)
    pub final_files: HashMap<String, FileContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtractionAttempt {
    pub type_name: String,
    pub module_name: String,
    pub extraction_strategy: String,
    pub imports_from_map: Vec<String>,
    pub imports_found_in_content: Vec<String>,
    pub final_imports_used: Vec<String>,
    pub content_preview: String,
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileContent {
    pub has_imports: bool,
    pub import_count: usize,
    pub first_import: Option<String>,
    pub content_preview: String,
}

impl ImportExtractionDebug {
    pub fn new() -> Self {
        Self {
            codegen_imports: HashMap::new(),
            module_content_preview: String::new(),
            extraction_attempts: Vec::new(),
            final_files: HashMap::new(),
        }
    }

    pub fn record_codegen_imports(&mut self, type_name: &str, imports: Vec<String>) {
        self.codegen_imports.insert(type_name.to_string(), imports);
    }

    pub fn record_module_content(&mut self, content: &str) {
        self.module_content_preview = content.chars().take(500).collect();
    }

    pub fn record_extraction(&mut self, attempt: ExtractionAttempt) {
        self.extraction_attempts.push(attempt);
    }

    pub fn record_final_file(&mut self, filename: &str, content: &str) {
        let lines: Vec<&str> = content.lines().collect();
        let has_imports = lines
            .iter()
            .any(|l| l.trim().starts_with("let ") && l.contains("import"));
        let import_count = lines
            .iter()
            .filter(|l| l.trim().starts_with("let ") && l.contains("import"))
            .count();
        let first_import = lines
            .iter()
            .find(|l| l.trim().starts_with("let ") && l.contains("import"))
            .map(|s| s.to_string());

        self.final_files.insert(
            filename.to_string(),
            FileContent {
                has_imports,
                import_count,
                first_import,
                content_preview: content.chars().take(500).collect(),
            },
        );
    }

    #[allow(dead_code)]
    pub fn to_json(&self) -> String {
        serde_json::to_string_pretty(self)
            .unwrap_or_else(|e| format!("Error serializing debug: {}", e))
    }

    pub fn summary(&self) -> String {
        let mut summary = String::new();

        summary.push_str("=== Import Extraction Debug Summary ===\n");
        summary.push_str(&format!(
            "Types with codegen imports: {}\n",
            self.codegen_imports.len()
        ));

        for (type_name, imports) in &self.codegen_imports {
            if !imports.is_empty() {
                summary.push_str(&format!("  {} -> {} imports\n", type_name, imports.len()));
            }
        }

        summary.push_str(&format!(
            "\nExtraction attempts: {}\n",
            self.extraction_attempts.len()
        ));
        let successful = self
            .extraction_attempts
            .iter()
            .filter(|a| a.success)
            .count();
        summary.push_str(&format!("  Successful: {}\n", successful));

        // Check for mismatches
        let mismatches: Vec<_> = self
            .extraction_attempts
            .iter()
            .filter(|a| !a.imports_from_map.is_empty() && a.final_imports_used.is_empty())
            .collect();

        if !mismatches.is_empty() {
            summary.push_str(&format!(
                "\n⚠️  {} types lost their imports during extraction:\n",
                mismatches.len()
            ));
            for attempt in mismatches {
                summary.push_str(&format!(
                    "  - {}: had {} imports, used {}\n",
                    attempt.type_name,
                    attempt.imports_from_map.len(),
                    attempt.final_imports_used.len()
                ));
            }
        }

        summary.push_str(&format!("\nFinal files: {}\n", self.final_files.len()));
        let with_imports = self.final_files.values().filter(|f| f.has_imports).count();
        summary.push_str(&format!("  With imports: {}\n", with_imports));

        summary
    }
}
