//! Comprehensive tests for mod.ncl generation
//!
//! These tests ensure that:
//! 1. Builds are hermetic (same input = same output)
//! 2. Documentation format is correct and consistent
//! 3. Type descriptions are included when available
//! 4. Module structure follows the expected hierarchy
//! 5. Cross-references are generated correctly

use amalgam_core::ir::{Module, TypeDefinition};
use amalgam_parser::package::NamespacedPackage;
use std::collections::HashMap;

#[test]
fn test_hermetic_main_module_generation() {
    // Same inputs should produce identical outputs
    let pkg1 = create_test_package();
    let pkg2 = create_test_package();

    let output1 = pkg1.generate_main_module();
    let output2 = pkg2.generate_main_module();

    assert_eq!(
        output1, output2,
        "Hermetic build failed: same inputs produced different outputs"
    );
}

#[test]
fn test_main_module_contains_required_headers() {
    let pkg = create_test_package();
    let output = pkg.generate_main_module();

    // Must contain package name
    assert!(
        output.contains("# Package:"),
        "Missing package name header"
    );

    // Must contain generator attribution
    assert!(
        output.contains("# Auto-generated by Amalgam"),
        "Missing generator attribution"
    );

    // Must NOT contain timestamps (non-hermetic)
    assert!(
        !output.contains("Generated:") || !output.contains("UTC"),
        "Contains non-hermetic timestamp"
    );

    // Should list API groups
    assert!(output.contains("# API Groups:"), "Missing API groups section");
}

#[test]
fn test_main_module_lists_all_groups() {
    let pkg = create_test_package();
    let output = pkg.generate_main_module();

    // Should contain all test groups
    assert!(
        output.contains("apiextensions.crossplane.io"),
        "Missing apiextensions.crossplane.io group"
    );
    assert!(
        output.contains("pkg.crossplane.io"),
        "Missing pkg.crossplane.io group"
    );

    // Should show versions for each group
    assert!(output.contains("(v1)"), "Missing version listing");
}

#[test]
fn test_group_module_generation() {
    let pkg = create_test_package();
    let output = pkg
        .generate_group_module("apiextensions.crossplane.io")
        .expect("Should generate group module");

    // Must contain group name
    assert!(
        output.contains("# API Group: apiextensions.crossplane.io"),
        "Missing group name"
    );

    // Must list versions with type counts
    assert!(
        output.contains("# Versions:"),
        "Missing versions section"
    );
    assert!(
        output.contains("v1 (") && output.contains("types)"),
        "Missing version with type count"
    );

    // Must have proper imports
    assert!(
        output.contains("v1 = import \"./v1/mod.ncl\""),
        "Missing version import"
    );
}

#[test]
fn test_version_module_with_type_documentation() {
    let pkg = create_test_package_with_docs();
    let output = pkg
        .generate_version_module("apiextensions.crossplane.io", "v1")
        .expect("Should generate version module");

    // Must contain version identifier
    assert!(
        output.contains("# apiextensions.crossplane.io.v1"),
        "Missing version identifier"
    );

    // Must have "Available Types:" section with bullet format
    assert!(
        output.contains("# Available Types:"),
        "Missing 'Available Types:' header"
    );

    // Must include type with inline documentation
    assert!(
        output.contains("#   - Composition - "),
        "Missing type with inline doc (bullet format)"
    );
    assert!(
        output.contains("Defines how to compose resources"),
        "Missing type description"
    );

    // Must have proper type imports
    assert!(
        output.contains("Composition = import \"./Composition.ncl\""),
        "Missing type import"
    );
}

#[test]
fn test_version_module_without_documentation() {
    let pkg = create_test_package_without_docs();
    let output = pkg
        .generate_version_module("test.group", "v1")
        .expect("Should generate version module");

    // Should still list types even without docs
    assert!(
        output.contains("# Available Types:"),
        "Missing types section"
    );
    assert!(
        output.contains("#   - TestType"),
        "Missing type name (should work without docs)"
    );

    // Should NOT have trailing " - " when no doc
    let lines: Vec<&str> = output.lines().collect();
    let type_line = lines
        .iter()
        .find(|l| l.contains("TestType"))
        .expect("Should have TestType line");

    // If there's no doc, it should just be "#   - TestType\n" without trailing dash
    if !type_line.contains("TestType - ") {
        // This is fine - no trailing dash when no doc
        assert!(type_line.trim().ends_with("TestType"));
    }
}

#[test]
fn test_type_description_truncation() {
    let mut pkg = NamespacedPackage::new("test-pkg".to_string());

    // Add type with very long documentation
    let long_doc = "This is an extremely long documentation string that should be truncated at some reasonable character limit to avoid making the mod.ncl files too verbose and difficult to read";
    let type_def = TypeDefinition {
        name: "LongDocType".to_string(),
        doc: Some(long_doc.to_string()),
        ..Default::default()
    };

    pkg.add_type(
        "test.group".to_string(),
        "v1".to_string(),
        "longdoctype".to_string(),
        type_def,
    );

    let output = pkg
        .generate_version_module("test.group", "v1")
        .expect("Should generate");

    // Should truncate at 80 chars with ellipsis
    assert!(
        output.contains("..."),
        "Long documentation should be truncated with ellipsis"
    );

    // Should not contain the full long string
    assert!(
        !output.contains("difficult to read"),
        "Should truncate before end of string"
    );
}

#[test]
fn test_hermetic_version_module_generation() {
    let pkg1 = create_test_package_with_docs();
    let pkg2 = create_test_package_with_docs();

    let output1 = pkg1
        .generate_version_module("apiextensions.crossplane.io", "v1")
        .unwrap();
    let output2 = pkg2
        .generate_version_module("apiextensions.crossplane.io", "v1")
        .unwrap();

    assert_eq!(
        output1, output2,
        "Hermetic build failed: same inputs produced different version modules"
    );
}

#[test]
fn test_multiple_versions_in_group() {
    let mut pkg = NamespacedPackage::new("multi-version".to_string());

    // Add types to multiple versions
    for version in &["v1", "v1beta1", "v1alpha1"] {
        let type_def = TypeDefinition {
            name: format!("Type{}", version),
            ..Default::default()
        };
        pkg.add_type(
            "test.group".to_string(),
            version.to_string(),
            format!("type{}", version),
            type_def,
        );
    }

    let output = pkg
        .generate_group_module("test.group")
        .expect("Should generate group module");

    // Should list all versions
    assert!(output.contains("v1 (1 types)"), "Missing v1");
    assert!(output.contains("v1beta1 (1 types)"), "Missing v1beta1");
    assert!(output.contains("v1alpha1 (1 types)"), "Missing v1alpha1");

    // Versions should be sorted
    let v1_pos = output.find("v1 (1 types)").unwrap();
    let v1alpha1_pos = output.find("v1alpha1 (1 types)").unwrap();
    let v1beta1_pos = output.find("v1beta1 (1 types)").unwrap();

    assert!(v1_pos < v1alpha1_pos, "v1 should come before v1alpha1");
    assert!(v1alpha1_pos < v1beta1_pos, "v1alpha1 should come before v1beta1");
}

#[test]
fn test_type_name_casing_preserved() {
    let mut pkg = NamespacedPackage::new("test-pkg".to_string());

    // CRDs use various casing
    let type_def = TypeDefinition {
        name: "CompositeResourceDefinition".to_string(), // PascalCase
        ..Default::default()
    };

    pkg.add_type(
        "test.group".to_string(),
        "v1".to_string(),
        "compositeresourcedefinition".to_string(), // lowercase key
        type_def,
    );

    let output = pkg
        .generate_version_module("test.group", "v1")
        .expect("Should generate");

    // Should preserve PascalCase in output
    assert!(
        output.contains("CompositeResourceDefinition = import \"./CompositeResourceDefinition.ncl\""),
        "Should preserve PascalCase in type name and filename"
    );

    // Should NOT use lowercase
    assert!(
        !output.contains("compositeresourcedefinition ="),
        "Should not use lowercase for type exports"
    );
}

#[test]
fn test_valid_nickel_syntax() {
    let pkg = create_test_package_with_docs();
    let output = pkg.generate_main_module();

    // Basic syntax checks
    assert!(output.contains("{\n"), "Should start with opening brace");
    assert!(output.ends_with("}\n"), "Should end with closing brace");

    // Count braces
    let open_braces = output.matches('{').count();
    let close_braces = output.matches('}').count();
    assert_eq!(
        open_braces, close_braces,
        "Unbalanced braces in generated Nickel"
    );

    // Imports should have proper syntax
    for line in output.lines() {
        if line.contains("import") {
            assert!(
                line.contains("\"") && line.matches('"').count() == 2,
                "Import line should have quoted path: {}",
                line
            );
            assert!(
                line.trim().ends_with(','),
                "Import line should end with comma: {}",
                line
            );
        }
    }
}

#[test]
fn test_no_empty_sections() {
    let mut pkg = NamespacedPackage::new("empty-test".to_string());

    // Create package with no types
    pkg.add_type(
        "test.group".to_string(),
        "v1".to_string(),
        "dummy".to_string(),
        TypeDefinition::default(),
    );

    let output = pkg.generate_main_module();

    // Should not have empty "API Groups:" section
    if output.contains("# API Groups:") {
        // If the section exists, it should list at least one group
        let lines: Vec<&str> = output.lines().collect();
        let groups_idx = lines.iter().position(|l| l.contains("# API Groups:"));
        if let Some(idx) = groups_idx {
            let next_line = lines.get(idx + 1);
            assert!(
                next_line.is_some() && !next_line.unwrap().is_empty(),
                "API Groups section should not be empty"
            );
        }
    }
}

// Helper functions to create test data

fn create_test_package() -> NamespacedPackage {
    let mut pkg = NamespacedPackage::new("test-package".to_string());

    pkg.add_type(
        "apiextensions.crossplane.io".to_string(),
        "v1".to_string(),
        "composition".to_string(),
        TypeDefinition {
            name: "Composition".to_string(),
            ..Default::default()
        },
    );

    pkg.add_type(
        "pkg.crossplane.io".to_string(),
        "v1".to_string(),
        "provider".to_string(),
        TypeDefinition {
            name: "Provider".to_string(),
            ..Default::default()
        },
    );

    pkg
}

fn create_test_package_with_docs() -> NamespacedPackage {
    let mut pkg = NamespacedPackage::new("test-package".to_string());

    pkg.add_type(
        "apiextensions.crossplane.io".to_string(),
        "v1".to_string(),
        "composition".to_string(),
        TypeDefinition {
            name: "Composition".to_string(),
            doc: Some("Defines how to compose resources into higher level abstractions".to_string()),
            ..Default::default()
        },
    );

    pkg.add_type(
        "apiextensions.crossplane.io".to_string(),
        "v1".to_string(),
        "compositionrevision".to_string(),
        TypeDefinition {
            name: "CompositionRevision".to_string(),
            doc: Some("Revision of a Composition".to_string()),
            ..Default::default()
        },
    );

    pkg
}

fn create_test_package_without_docs() -> NamespacedPackage {
    let mut pkg = NamespacedPackage::new("no-docs-package".to_string());

    pkg.add_type(
        "test.group".to_string(),
        "v1".to_string(),
        "testtype".to_string(),
        TypeDefinition {
            name: "TestType".to_string(),
            doc: None, // No documentation
            ..Default::default()
        },
    );

    pkg
}
