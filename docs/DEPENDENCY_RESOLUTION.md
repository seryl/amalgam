# Full Dependency Resolution Design

## Overview

This document outlines what "full dependency resolution" means for amalgam's vendor system and how it should be implemented.

## Core Components

### 1. Transitive Dependency Management

When package A depends on package B, and B depends on package C, the resolver must:
- Automatically fetch and install C when installing A
- Build a complete dependency graph
- Handle diamond dependencies (when multiple packages depend on different versions of the same package)

**Example:**
```
crossplane.io@1.14.0
  ├── k8s.io@1.29.0
  │   └── apimachinery@0.29.0
  └── controller-runtime@0.16.0
      └── k8s.io@1.29.0 (deduped)
```

### 2. Version Constraint Solving

Support for semantic versioning constraints:

```toml
# In nickel.toml
[dependencies]
"k8s.io" = ">=1.28.0,<1.30.0"      # Range constraint
"crossplane.io" = "~1.14.0"         # Compatible with 1.14.x
"aws.upbound.io" = "^0.44.0"        # Compatible with 0.x.x, >=0.44.0
"custom-crds" = "=2.1.0"            # Exact version
```

**Constraint Types:**
- `^` (caret): Compatible with specified version (same major version)
- `~` (tilde): Approximately equivalent (same minor version)
- `>=`, `<=`, `>`, `<`: Range boundaries
- `=`: Exact match
- `,`: AND operator for multiple constraints
- `||`: OR operator for alternatives

### 3. Dependency Conflict Resolution

The resolver must handle conflicts intelligently:

```rust
// Example conflict scenario
Project requires: k8s.io@>=1.28.0
crossplane.io requires: k8s.io@1.29.0
aws-provider requires: k8s.io@<1.29.0

// Resolution attempt:
// 1. Find intersection: k8s.io@1.28.x satisfies all
// 2. If no intersection: report conflict with details
```

**Conflict Resolution Strategies:**
1. **Automatic Resolution**: Find a version satisfying all constraints
2. **User Override**: Allow explicit version pinning
3. **Duplicate Versions**: Support multiple versions in isolated scopes (advanced)

### 4. Lock File Generation

Create a `nickel.lock` file recording exact resolved versions:

```toml
# nickel.lock - Generated by amalgam
# This file is automatically @generated.
# It is not intended for manual editing.
version = 1

[[package]]
name = "k8s.io"
version = "1.29.0"
source = "registry+amalgam"
checksum = "sha256:abc123def456..."
dependencies = [
  "apimachinery 0.29.0",
]

[[package]]
name = "crossplane.io"
version = "1.14.2"
source = "git+https://github.com/crossplane/crossplane#v1.14.2"
checksum = "sha256:789xyz..."
dependencies = [
  "k8s.io 1.29.0",
  "controller-runtime 0.16.0",
]

[[package]]
name = "controller-runtime"
version = "0.16.0"
source = "registry+amalgam"
checksum = "sha256:def789..."
dependencies = [
  "k8s.io 1.29.0",
]
```

## Resolution Algorithm

### Basic Resolution Flow

```rust
fn resolve_dependencies(manifest: ProjectManifest) -> Result<DependencyGraph> {
    let mut graph = DependencyGraph::new();
    let mut queue = VecDeque::from(manifest.dependencies);
    let mut resolved = HashMap::new();
    let mut constraints = ConstraintSolver::new();

    while let Some(dep) = queue.pop_front() {
        // Check if already resolved with compatible version
        if let Some(existing) = resolved.get(&dep.name) {
            if !constraints.add_constraint(&dep.name, &dep.version_req) {
                return Err(ConflictError {
                    package: dep.name,
                    existing: existing.version.clone(),
                    requested: dep.version_req,
                });
            }
            continue;
        }

        // Fetch available versions
        let versions = fetch_available_versions(&dep.name)?;

        // Select best matching version
        let selected = constraints.solve(&dep.name, &versions)?;

        // Fetch package metadata
        let package = fetch_package(&dep.name, &selected)?;

        // Add to graph
        graph.add_node(package.clone());

        // Queue transitive dependencies
        for transitive in &package.dependencies {
            queue.push_back(transitive.clone());
        }

        resolved.insert(dep.name.clone(), package);
    }

    // Verify graph integrity
    graph.verify_no_cycles()?;
    graph.verify_all_constraints_satisfied()?;

    Ok(graph)
}
```

### Advanced SAT-based Solver

For complex dependency graphs, use a SAT solver approach:

```rust
struct SATResolver {
    clauses: Vec<Clause>,
    variables: HashMap<PackageVersion, Variable>,
}

impl SATResolver {
    fn solve(&mut self) -> Result<Solution> {
        // Convert dependency constraints to boolean clauses
        self.build_implication_graph();

        // Add version conflict clauses (can't have two versions)
        self.add_mutex_clauses();

        // Use DPLL or CDCL algorithm
        let assignment = self.dpll_solve()?;

        // Convert boolean assignment back to package versions
        self.extract_solution(assignment)
    }

    fn build_implication_graph(&mut self) {
        // If package A@1.0.0 then one of its deps must be satisfied
        // A@1.0.0 => (B@2.0.0 || B@2.1.0)
    }

    fn add_mutex_clauses(&mut self) {
        // Can't have both A@1.0.0 and A@2.0.0
        // ¬(A@1.0.0 ∧ A@2.0.0)
    }
}
```

## Command-Line Interface

### Installation Commands

```bash
# Install with full resolution
$ amalgam vendor install
Resolving dependencies...
  Fetching version list for k8s.io...
  Fetching version list for crossplane.io...
  Solving constraints...
  Selected: k8s.io@1.29.0
  Selected: crossplane.io@1.14.2
Installing packages...
  ✓ k8s.io@1.29.0
  ✓ crossplane.io@1.14.2
Lock file written to nickel.lock

# Show dependency tree
$ amalgam vendor tree
project@0.1.0
├── crossplane.io@1.14.0
│   ├── k8s.io@1.29.0
│   │   └── apimachinery@0.29.0
│   └── controller-runtime@0.16.0
│       └── k8s.io@1.29.0 (deduped)
└── aws.upbound.io@0.44.0
    └── crossplane.io@1.14.0 (deduped)

# Update dependencies respecting constraints
$ amalgam vendor update
Checking for updates...
  k8s.io@1.29.0 -> 1.29.1 (patch available)
  crossplane.io@1.14.2 (up to date)
Updating k8s.io to 1.29.1...
Lock file updated

# Add with conflict detection
$ amalgam vendor add some-package@2.0.0
Resolving some-package@2.0.0...
Error: Version conflict detected

  some-package@2.0.0 requires k8s.io@>=1.30.0
  but crossplane.io@1.14.0 requires k8s.io@<1.30.0

Possible solutions:
  1. Downgrade some-package to 1.x (supports k8s.io@1.29.0)
  2. Upgrade crossplane.io to 1.15.0 (supports k8s.io@1.30.0)
  3. Override with --force (may cause compatibility issues)

# Check for conflicts
$ amalgam vendor check
Analyzing dependency graph...
  ✓ All version constraints satisfied
  ✓ No circular dependencies detected
  ✓ Lock file is up to date
```

### Resolution Strategies

```bash
# Conservative: prefer minimum versions
$ amalgam vendor install --strategy=minimal

# Aggressive: prefer latest compatible versions
$ amalgam vendor install --strategy=latest

# Balanced: prefer latest patch versions (default)
$ amalgam vendor install --strategy=balanced
```

## Error Handling

### Clear Conflict Reporting

```
Error: Cannot resolve dependencies

  Package 'aws-provider' requires 'crossplane.io@^1.15.0'
  Package 'gcp-provider' requires 'crossplane.io@~1.14.0'

  These constraints cannot be satisfied simultaneously.

  The conflict path:
    your-project
    └── aws-provider@0.45.0
        └── crossplane.io@^1.15.0 ✗
    └── gcp-provider@0.30.0
        └── crossplane.io@~1.14.0 ✗

  Suggestions:
    • Downgrade aws-provider to 0.44.x which supports crossplane.io@1.14
    • Upgrade gcp-provider to 0.31.x which supports crossplane.io@1.15
    • Remove one of the conflicting dependencies
```

### Cycle Detection

```
Error: Circular dependency detected

  crossplane-contrib@1.0.0 depends on crossplane@1.14.0
  crossplane@1.14.0 depends on crossplane-contrib@^1.0.0

  This creates a circular dependency that cannot be resolved.

  Please check with the package maintainers to fix this issue.
```

## Implementation Phases

### Phase 1: Basic Constraint Parsing
- Parse version requirements from nickel.toml
- Implement semantic version comparison
- Support basic operators (^, ~, =, >, <)

### Phase 2: Simple Resolution
- Fetch available versions from registry
- Select best matching version for direct dependencies
- Generate basic lock file

### Phase 3: Transitive Dependencies
- Fetch and parse dependency metadata
- Build dependency graph
- Detect simple conflicts

### Phase 4: Advanced Resolution
- Implement SAT-based solver
- Support complex constraint combinations
- Add backtracking for conflict resolution

### Phase 5: Optimization
- Cache version metadata
- Parallel fetching
- Incremental resolution for updates

## Testing Strategy

### Unit Tests
```rust
#[test]
fn test_version_constraint_parsing() {
    let constraint = VersionReq::parse(">=1.2.0, <2.0.0").unwrap();
    assert!(constraint.matches(&Version::parse("1.5.0").unwrap()));
    assert!(!constraint.matches(&Version::parse("2.0.0").unwrap()));
}

#[test]
fn test_conflict_detection() {
    let mut resolver = Resolver::new();
    resolver.add_constraint("k8s.io", ">=1.29.0");
    resolver.add_constraint("k8s.io", "<1.29.0");
    assert!(resolver.has_conflict());
}
```

### Integration Tests
```rust
#[test]
fn test_complex_resolution() {
    // Create a mock registry with known packages
    let registry = MockRegistry::new()
        .with_package("crossplane.io", "1.14.0", deps![("k8s.io", "~1.29.0")])
        .with_package("k8s.io", "1.29.0", deps![])
        .with_package("k8s.io", "1.30.0", deps![]);

    let manifest = parse_manifest(r#"
        [dependencies]
        "crossplane.io" = "^1.14.0"
        "k8s.io" = ">=1.29.0"
    "#);

    let result = resolve(manifest, registry);
    assert_eq!(result.get("k8s.io").version, "1.29.0"); // Should pick 1.29, not 1.30
}
```

## Performance Considerations

### Caching Strategy
- Cache version lists for 24 hours
- Cache package metadata indefinitely (immutable)
- Use ETags for efficient cache validation

### Parallel Operations
- Fetch version lists in parallel
- Download packages concurrently
- Parse metadata in worker threads

### Memory Optimization
- Stream large package downloads
- Lazy-load transitive dependency metadata
- Use compact representation for version ranges

## Security Considerations

### Package Verification
- Verify checksums from lock file
- Support package signatures
- Validate HTTPS certificates

### Supply Chain Security
- Record package provenance
- Support vulnerability scanning
- Alert on known vulnerable versions

## Future Extensions

### 1. Workspace Support
Support for monorepos with multiple packages:
```toml
[workspace]
members = ["packages/*", "apps/*"]

[workspace.dependencies]
"k8s.io" = "1.29.0"  # Shared version for all workspace members
```

### 2. Override Mechanism
Allow explicit version overrides:
```toml
[overrides]
"k8s.io" = { version = "1.30.0", reason = "Testing new features" }
```

### 3. Feature Flags
Optional dependencies based on features:
```toml
[dependencies]
"monitoring" = { version = "1.0.0", optional = true }

[features]
default = []
observability = ["monitoring"]
```

### 4. Private Registries
Support for corporate/private package registries:
```toml
[registries]
corporate = { url = "https://packages.internal.company.com", token = "${REGISTRY_TOKEN}" }

[dependencies]
"internal-crds" = { version = "1.0.0", registry = "corporate" }
```

## References

- [Cargo's Dependency Resolution](https://doc.rust-lang.org/cargo/reference/resolver.html)
- [NPM's Dependency Resolution Algorithm](https://npm.github.io/how-npm-works-docs/npm3/how-npm3-works.html)
- [PubGrub Version Solving Algorithm](https://github.com/dart-lang/pub/blob/master/doc/solver.md)
- [SAT-based Dependency Solving](https://research.swtch.com/version-sat)
